module sat.
import common_constr.

% '#!='(X,Y) =>  X #!= Y.
% '#/\\'(X,Y) =>  X #/\ Y.
% '#<'(X,Y) =>  X #< Y.
% '#<='(X,Y) =>  X #=< Y.
% '#<=>'(X,Y) =>  X #<=> Y.
% '#='(X,Y) => X #= Y.
% '#=<'(X,Y) =>  X #=< Y.
% '#=>'(X,Y) =>  X #=> Y.
% '#>'(X,Y) =>  X #> Y.
% '#>='(X,Y) =>  X #>= Y.
% '#\\/'(X,Y) =>  X #\/ Y.
% '#^'(X,Y) =>  X #^ Y.
% '#~'(X) =>  #~ X.
%  '::'(Vars,Domain) => '::'(Vars,Domain).
% all_different(FDVars) => all_different(FDVars).
% all_different_except_0(Xs) => all_different_except_0(Xs).
% all_distinct(FDVars) => all_distinct(FDVars).
% assignment(FDVars1,FDVars2) => assignment(FDVars1,FDVars2).
% at_least(N,X,V) => at_least(N,X,V).
% at_most(N,X,V) => at_most(N,X,V).
% circuit(L) => circuit(L).
% count(V,FDVars,Rel,N) => count(V,FDVars,Rel,N).
% cumulative(Starts,Durations,Resources,Limit) => cumulative(Starts,Durations,Resources,Limit).
% decreasing(FDVars) => decreasing(FDVars).
% decreasing_strict(FDVars) => decreasing_strict(FDVars).
% diffn(RectangleList) => diffn(RectangleList).
% disjunctive_tasks(Tasks) => disjunctive_tasks(Tasks).
% element(I,FDVars,V) => element(I,FDVars,V).
% exactly(N, X, V) => exactly(N, X, V).
% fd_disjoint(DVar1,DVar2) => fd_disjoint(DVar1,DVar2).
% fd_dom(FDVar) = fd_dom(FDVar).
% fd_false(FDVar,Elm) => fd_false(FDVar,Elm).
% fd_max(FDVar) = fd_max(FDVar).
% fd_min(FDVar) = fd_min(FDVar).
% fd_min_max(FDVar,Min,Max) => fd_min_max(FDVar,Min,Max).
% fd_next(FDVar,Elm) = fd_next(FDVar,Elm).
% fd_prev(FDVar,Elm) = fd_prev(FDVar,Elm).
% fd_set_false(FDVar,Elm) => fd_set_false(FDVar,Elm).
% fd_size(FDVar) = fd_size(FDVar).
% fd_true(FDVar,Elm) => fd_true(FDVar,Elm).
% fd_vector_min_max(Min,Max) => fd_vector_min_max(Min,Max).
% global_cardinality(FDVars,Pairs) => global_cardinality(FDVars,Pairs).
% increasing(FDVars) => increasing(FDVars).
% increasing_strict(FDVars) => increasing_strict(FDVars).
% lex_le(L1,L2) => lex_le(L1,L2).
% lex_lt(L1,L2) => lex_lt(L1,L2).
% matrix_element(M,I,J,MIJ) => matrix_element(M,I,J,MIJ).
% neqs(Neqs) => neqs(Neqs).
% new_dvar() = new_dvar().
% new_fd_var() = new_fd_var().
% notin(VarOrVars,D) => notin(VarOrVars,D).
% nvalue(N,L) => nvalue(N,L).
% regular(W, Q, S, M, Q0, Fs) => regular(W, Q, S, M, Q0, Fs).
% scalar_product(A, X, Product) => scalar_product(A, X, Product).
% serialized(Starts,Durations) => serialized(Starts,Durations).
% solve(Options,Vars) => solve(Options,Vars)
% solve(Vars) => solve(Vars).
% solve_all(Options,Vars) = solve_all(Options,Vars).
% solve_all(Vars) = solve_all(Vars).
% subcircuit(FDVars) => subcircuit(FDVars).
% subcircuit_grid(A) => subcircuit_grid(A).
% subcircuit_grid(A,K) => subcircuit_grid(A,K).
% subcircuit_grid(A,K,EMap) => subcircuit_grid(A,K,EMap).
% table_in(Vars, Tuples) => table_in(Vars, Tuples).
% table_notin(Vars, Tuples) => table_notin(Vars, Tuples).

'::'(Vars,Domain) =>
    bp.'_$_picat_in'(sat,Vars,Domain).

% '#='(X,Y) => X #= Y.
'#='(X,Y) => bp.'$='(X,Y).

% '#>='(X,Y) =>  X #>= Y.
'#>='(X,Y) => bp.'$>='(X,Y).

% '#>'(X,Y) =>  X #> Y.
'#>'(X,Y) => bp.'$>'(X,Y).

% '#<'(X,Y) =>  X #< Y.
'#<'(X,Y) => bp.'$<'(X,Y).

% '#=<'(X,Y) =>  X #=< Y.
'#=<'(X,Y) => bp.'$=<'(X,Y).

% '#!='(X,Y) =>  X #!= Y.
'#!='(X,Y) => bp.'$\\='(X,Y).

'#\\='(X,Y) => bp.'$\\='(X,Y).

% '#<=>'(X,Y) =>  X #<=> Y.
'#<=>'(X,Y) => bp.'$<=>'(X,Y).

% '#=>'(X,Y) =>  X #=> Y.
'#=>'(X,Y) => 
   bp.'$=>'(X,Y).

% '#/\\'(X,Y) =>  X #/\ Y.
'#/\\'(X,Y) => bp.'$/\\'(X,Y).

% '#\\/'(X,Y) =>  X #\/ Y.
'#\\/'(X,Y) => bp.'$\\/'(X,Y).

% '#^'(X,Y) =>  X #^ Y.
'#^'(X,Y) => bp.'$\\'(X,Y).

% '#~'(X) =>  #~ X.
'#~'(X) => bp.'$\\'(X).

%
all_equal(A), array(A) =>
    all_equal(to_list(A)).
all_equal([X|Xs]) =>
    all_equal(X,Xs).
all_equal([X]) => true.
all_equal([]) => true.    
    
    
all_equal(X,[]) => true.
all_equal(X,[Y|Ys]) =>
    X #= Y,
    all_equal(X,Ys).
    
% Ensure that L[Z] the first maximum element of L.
argmax(L,Z), list(L) =>
    argmax(to_array(L), Z).
argmax(A,Z), array(A) =>
    N = length(A),
    Z :: 1..N,
    Xs = new_list(N),
    foreach (I in 1..N)
        Xs[I] #= N*A[I]+N-I-1
    end,
    M #= max(Xs),
    foreach (I in 1..N)
        B #<=> Z #= I,
        B #<=> Xs[I] #= M
    end.
argmax(A,Z) =>
    handle_exception($dvar_or_int_collection_expected(A), argmax).

%
% The sum of the weights of the items in each bin does not exceed the capacity C.
% For each item I, Bin[I] indicates the bin to which item I is put, and W[i] is the weight of item I.
%
bin_packing(C,Bin,W) =>
    fd_min_max(Bin,BinMin,BinMax),
    N = Bin.len,
    foreach(BN in BinMin..BinMax) 
        sum([W[I] * (Bin[I] #= BN) : I in 1..N]) #=< C
    end.

%
% The sum of the weights of the items in each bin BN is equal to Load[BN].
% For each item I, Bin[I] indicates the bin to which item I is put, and W[i] is the weight of item I.
%
bin_packing_load(Load, Bin, W) =>
    sum(Load) #= sum(W),
    LoadLen = Load.len,
    BinLen = Bin.len,
    Bin :: 1..LoadLen,
    foreach(B in 1..LoadLen) 
        Load[B] #= sum([W[I] * (Bin[I] #= B) : I in 1..BinLen])
    end.
    
% all_different(FDVars) => all_different(FDVars).
all_different(FDVars) =>
    (array(FDVars) -> to_list(FDVars) = List; List = FDVars),
    bp.'$alldifferent'(List).

% all_distinct(FDVars) => all_distinct(FDVars).
all_distinct(FDVars) =>
    all_different(FDVars).

%
% Requires that all non-zero values in Xs are distinct.
%
alldifferent_except_0(Xs) =>
    all_different_except_0(Xs).

all_different_except_0(Xs) =>
    (list(Xs) ->
        L = Xs
    ;array(Xs) ->
        L = to_list(Xs)
    ;
        handle_exception($dvar_or_int_collection_expected(Xs), all_different_except_0)
    ),
    bp.'$alldifferent_except_0'(L).

all_different_except_0_aux(Xs), dvar_or_int_array(Xs) =>
    N = len(Xs),
    Bs = new_array(N),
    Bs :: 0..1,
    foreach (I in 1..N)
        Bs[I] #<=> Xs[I] #= 0
    end,
    foreach (I in 1..N-1, J in I+1..N)
        bp.attach_complex_imp([Bs[I],Bs[J]], $ic_neq(Xs[I], Xs[J]))    % ~Bs[I] /\ ~Bs[J] -> Xs[I] != Xs[J]
    end.
all_different_except_0_aux(Xs) =>
    N = len(Xs),
    foreach(I in 1..N-1, J in I+1..N)
        Xs[I] #= 0 #\/ Xs[J] #= 0 #\/ Xs[I] #!= Xs[J]
    end.


% element(I,FDVars,V) => element(I,FDVars,V).
element(I,FDVars,V) =>
    (array(FDVars) -> to_list(FDVars) = List; List = FDVars),
    (bp.dvar_or_int_list(List) -> true; handle_exception($dvar_or_int_list_expected(List), element)),
    bp.'$element'(I,List,V,sat).

% 0-based indexing
%element0(I,FDVars,V) => element0(I,FDVars,V).
element0(I,FDVars,V) =>
    (array(FDVars) -> to_list(FDVars) = List; List = FDVars),
    (bp.dvar_or_int_list(List) -> true; handle_exception($dvar_or_int_list_expected(List), element)),
    bp.'$element0'(I,List,V,sat).

% fd_disjoint(DVar1,DVar2) => fd_disjoint(DVar1,DVar2).
fd_disjoint(DVar1,DVar2), dvar_or_int(DVar1), dvar_or_int(DVar2) => bp.b_DM_DISJOINT_cc(DVar1,DVar2).
fd_disjoint(DVar1,DVar2) =>
    Source = fd_disjoint,
    (dvar_or_int(DVar1) -> handle_exception($dvar_expected(DVar2), Source); handle_exception($dvar_expected(DVar1), Source)).

% fd_set_false(FDVar,Elm) => fd_set_false(FDVar,Elm).
fd_set_false(FDVar,Elm), dvar_or_int(FDVar), integer(Elm) => 
    bp.domain_set_false(FDVar,Elm).
fd_set_false(FDVar,Elm) =>
    Source = fd_set_false,
    (integer(Elm) ->
        handle_exception($dvar_expected(FDVar), Source)
    ;
        handle_exception($integer_expected(Elm), Source)
    ).

% count(V,FDVars,Rel,N) => count(V,FDVars,Rel,N).
count(V,FDVars,Rel,N) =>
    (array(FDVars) -> to_list(FDVars) = List; List = FDVars),
    reified_bool_vars(List,V,Bs),
    count_aux(Bs,Rel,N).

reified_bool_vars([],_V,Bs) => Bs = [].
reified_bool_vars([E|List],V,Bs) =>
    Bs = [B|BsR],
    B #<=> (V #= E),
    reified_bool_vars(List,V,BsR).

count_aux(Bs,'#=', N) => sum(Bs) #= N.
count_aux(Bs,'#!=', N) => sum(Bs) #!= N.
count_aux(Bs,'#\\=', N) => sum(Bs) #!= N.
count_aux(Bs,'#>', N) => sum(Bs) #> N.
count_aux(Bs,'#>=', N) => sum(Bs) #>= N.
count_aux(Bs,'#<', N) => sum(Bs) #< N.
count_aux(Bs,'#=<', N) => sum(Bs) #=< N.
count_aux(Bs,'#<=', N) => sum(Bs) #=< N.

count(V,FDVars,N) =>
    count(V,FDVars,'#=',N).

count_eq_reif(List,V,N,B) =>
    Ni :: 0..length(List),
    count(V,List,#=,Ni),
    B #<=> (N #= Ni).
	
% cumulative(Starts,Durations,Resources,Limit) => cumulative(Starts,Durations,Resources,Limit).
cumulative(Starts,Durations,Resources,Limit) =>
    (array(Starts) -> to_list(Starts) = SList; SList = Starts),    
    (array(Durations) -> to_list(Durations) = DList; DList = Durations),    
    (array(Resources) -> to_list(Resources) = RList; RList = Resources),
%    println($cumu(Starts,Durations,Resources,Limit)),
    bp.bp_cumulative(SList,DList,RList,Limit,sat).
    
% diffn(RectangleList) => diffn(RectangleList).
diffn(RectangleList) =>
    (array(RectangleList) -> to_list(RectangleList) = RList; RList = RectangleList),
    bp.bp_diffn(RList,sat).

diffn(VecX,VecY,VecDX,VecDY) =>
    Rects = [[VecX[I],VecY[I],VecDX[I],VecDY[I]] : I in 1 .. length(VecX)],
    diffn(Rects).

diffn_nonstrict(X,Y,DX,DY) =>
    sat_check_array(X,X1,diffn_nonstrict),
    sat_check_array(Y,Y1,diffn_nonstrict),
    sat_check_array(DX,DX1,diffn_nonstrict),
    sat_check_array(DY,DY1,diffn_nonstrict),
    diffn_nonstrict_aux(X1,Y1,DX1,DY1).

sat_check_array(X,AX,Source), list(X) => AX = to_array(X).
sat_check_array(X,AX,Source), array(X) => AX = X.
sat_check_array(X,AX,Source) =>
    handle_exception($list_or_array_expected(X), Source).
        
diffn_nonstrict_aux(X,Y,DX,DY) =>
    N = X.len,
    foreach(I in 1..N, J in I+1..N, DX[I] !== 0, DX[J] !== 0, DY[I] !== 0, DY[J] !== 0)
        X[I] + DX[I] #=< X[J] #\/
        Y[I] + DY[I] #=< Y[J] #\/
        X[J] + DX[J] #=< X[I] #\/
        Y[J] + DY[J] #=< Y[I] #\/
        DX[I] #= 0 #\/
        DX[J] #= 0 #\/
        DY[I] #= 0 #\/
        DY[J] #= 0
    end.
        
% disjunctive_tasks(Tasks) => disjunctive_tasks(Tasks).
disjunctive_tasks(Tasks) =>
    (array(Tasks) -> to_list(Tasks) = TList; TList = Tasks),    
    disjunctive_tasks_aux(TList).

disjunctive_tasks_aux([]) => true.
disjunctive_tasks_aux([disj_tasks(S1,D1,S2,D2)|Tasks]) =>
    S1+D1 #=< S2 #\/ S2+D2 #=< S1,
    disjunctive_tasks_aux(Tasks).
disjunctive_tasks_aux(Tasks) =>
    handle_exception($invalid_tasks(Tasks), disjunctive_tasks).

% assignment(FDVars1,FDVars2) => assignment(FDVars1,FDVars2).
assignment(FDVars1,FDVars2) =>
    bp.picat_preprocess_assignment(FDVars1,FDVars2,Vect1,Vect2,N),
    M1 = new_array(N,N),                         % M1[I,J] = 1 iff FDVars1[I] = J
    M1 :: 0..1,
    M2 = new_array(N,N),                         % M2[I,J] = 1 iff FDVars2[I] = J
    foreach (I in 1..N, J in 1..N)               % M2 is M1's transpose
        M2[I,J] = M1[J,I]
    end,
    foreach (I in 1..N, J in 1..N)               % channel
        M1[I,J] #<=> Vect1[I] #= J,
        M2[I,J] #<=> Vect2[I] #= J
    end,
    foreach (J in 1..N)                         
        sum([M1[I, J] : I in 1..N]) #= 1          % all_different(FDVars1),
    end.


% solve(Vars) => solve(Vars).
solve(Vars) => solve([],Vars).

% solve(Options,Vars) => solve(Options,Vars)
solve(Options,Vars) =>
    (bp.dvar_or_int_list(Vars) ->
        VList = Vars
    ;
        VList = vars(Vars),
        (bp.dvar_or_int_list(VList) ->
            true
        ;
            handle_exception($free_var_not_allowed(Vars), solve)
        )
    ),
    (select($report(Call), Options,Options1) ->
        Options2 = [$report('$dyna_eval_pred'(['$picat_top_level'],Call))|Options1]
    ;
        Options2 = Options
    ),
    (select($dump(File), Options2,Options3) ->
        AtomFile = to_atom(File),
        Options4 = [$dump(AtomFile)|Options3]
    ;         
        Options4 = Options2
    ),        
    bp.sat_solve(Options4,VList).    

solve_all(Vars) = solve_all([],Vars).

solve_all(Options,Vars) =
    findall(Vars, solve(Options,Vars)).

%%%%%%%%%%%%%%%%%%%%%%%% common to cp and sat modules %%%%%%%%%%%%%%%%%%%%%%
% new_fd_var() = new_fd_var().
new_fd_var() = FDVar =>
    bp.fd_new_var(FDVar).

new_dvar() = FDVar =>
    bp.fd_new_var(FDVar).

%%
table_in(Vars,Tuples) =>
    bp.'$table_in'(Vars,Tuples).

%%
notin(Vars,Domain) =>
    bp.'_$_picat_notin'(sat,Vars,Domain).

%%
table_notin(Vars,Tuples) =>
    bp.'$table_notin'(Vars,Tuples).

% fd_dom(FDVar) = fd_dom(FDVar).
fd_dom(FDVar) = List, integer(FDVar) => List = [FDVar].
fd_dom(FDVar) = List, dvar(FDVar) => bp.domain_min_max(FDVar,Min,Max), bp.fd_domain(FDVar,List,Min,Max).
fd_dom(FDVar) = _List => 
    handle_exception($dvar_expected(FDVar), fd_dom).

% fd_false(FDVar,Elm) => fd_false(FDVar,Elm).
fd_false(FDVar,Elm),
    dvar_or_int(FDVar),
    integer(Elm)
 =>
    bp.b_DM_FALSE_cc(FDVar,Elm).
fd_false(FDVar,Elm) =>
    bp.expect_dvar_int(FDVar,Elm,fd_false).

% fd_max(FDVar) = fd_max(FDVar).
fd_max(VarOrVars) = Max =>
    bp.fd_min_max(VarOrVars,_,Max).

% fd_min(FDVar) = fd_min(FDVar).
fd_min(VarOrVars) = Min =>
    bp.fd_min_max(VarOrVars,Min,_).    

% fd_min_max(FDVar,Min,Max) => fd_min_max(FDVar,Min,Max).
fd_min_max(VarOrVars,Min,Max) =>
    bp.fd_min_max(VarOrVars,Min,Max).

% fd_next(FDVar,Elm) = fd_next(FDVar,Elm).
fd_next(FDVar,Elm) = NextElm, 
    dvar(FDVar), integer(Elm) 
 =>
    (bp.domain_next_inst(FDVar,Elm, NextElm) -> true; handle_exception(failed,fd_next)).
fd_next(FDVar,Elm) = _NextElm =>
    bp.expect_dvar_int(FDVar,Elm,fd_next).

% fd_prev(FDVar,Elm) = fd_prev(FDVar,Elm).
fd_prev(FDVar,Elm) = PrevElm,
    dvar(FDVar), integer(Elm) 
 =>
    (bp.b_DM_PREV_ccf(FDVar,Elm, PrevElm) -> true; handle_exception(failed,fd_prev)).
fd_prev(FDVar,Elm) = _PrevElm =>
    bp.expect_dvar_int(FDVar,Elm,fd_prev).

% fd_size(FDVar) = fd_size(FDVar).
fd_size(FDVar) = Size =>
    (dvar(FDVar) -> 
        bp.b_DM_COUNT_cf(FDVar,Size)
    ; integer(FDVar) ->
        Size = 1
    ;
        handle_exception($dvar_expected(FDVar), fd_size)
    ).
    
% fd_true(FDVar,Elm) => fd_true(FDVar,Elm).
fd_true(FDVar,Elm),
    dvar_or_int(FDVar),
    integer(Elm)
 =>
    bp.b_DM_TRUE_cc(FDVar,Elm).
fd_true(FDVar,Elm) =>
    bp.expect_dvar_int(FDVar,Elm,fd_true).

fd_vector_min_max(Min,Max) =>
    bp.fd_vector_min_max(Min,Max).

/************************************************************************* 
circuit(L): L is a list of variables X1,X2,...,Xn. An assignment
{X1->a1,X2->a2,...,Xn->an} satisfies this constraint if it forms a Hamilton cycle. 
To be more specific, each variable has a different value and no sub-cycles can be 
formed.  For example, for the constraint circult([X1,X2,X3,X4]), 
[3,4,2,1] is a solution, but [2,1,4,3] is not because it contains sub-cycles.
*************************************************************************/
circuit(L), list(L) =>
    A = to_array(L),
    circuit_aux(A).
circuit(A), array(A) =>
    circuit_aux(A).
circuit(L) =>
    handle_exception($array_or_list_expected(L), circuit).

circuit_aux({V}) => V = 1.
circuit_aux(A) =>                             % single-agent path finding
    N = length(A),
    A :: 1..N,
    foreach (I in 1..N)                       % not reflexive
        bp.domain_set_false(A[I],I)
    end,
    circuit_init_adj_matrix(H,A,N,NeibVect,TNeibVect),
    
    H :: 0..1,
    foreach (I in 1..N, J in 1..N, I !== J)   % channel
        if H[I,J] !== 0 then
            H[I, J] #<=> (A[I] #= J),
            if N > 2 then
                #~H[I,J] #\/ #~H[J,I]
            end
        end
    end,
    foreach (I in 1..N)                       
        sum([H[J,I] : J in 1..N]) #= 1         % each node has exactly one incoming edge
    end,

    circuit_choose_start(A,1, fd_size(A[1]), Start,1,N),
     % ban sub-cycles
    P = new_array(N),                          % P[I] is node I's position
    P[Start] = 1,
    P :: 1..N,
    circuit_preprocess(N,P,Start,NeibVect,TNeibVect),
     %
    foreach (I in 1..N, I !== Start)
        H[Start,I] #=> P[I] #= 2,         % H[Start,I] -> I is the successor of Start
        H[I, Start] #=> (P[I] #= N)        % H[I,Start] -> I is visited at time N
    end,
     % if edge (I,J) is in, then J's position is the successor of I's position
    foreach (I in 1..N, I !== Start, J in 1..N, J !== Start, H[I,J] !== 0)
        H[I,J] #=> P[J] #= P[I]+1
    end.

% H is the adjacent matrix representation of a Hamilton cycle in graph A
% set H[I,J] = 0 if (I,J) is not an edge in graph A
circuit_init_adj_matrix(H,A,N,NeibVect,TNeibVect) =>
    H = new_array(N,N),                         % H[I,J] = 1 iff (I,J) an edge in the Hamilton cycle
    NeibVect = new_array(N),                    % adjacency list
    TNeibVect = new_array(N),                   % adjacency list of the transpose graph
    foreach (I in 1..N, J in 1..N)              % H is a subgraph of A
        if fd_true(A[I],J) then
            true
        else
            H[I,J] = 0
        end
    end,
    foreach (I in 1..N)
        NeibVect[I] = [J : J in 1..N, H[I,J] !== 0],
        TNeibVect[I] = [J : J in 1..N, H[J,I] !== 0]
    end.

% choose a node that has the smallest out-degree to start with
circuit_choose_start(_A,CurIndex,_CurDeg,BestIndex,I,N), I > N => BestIndex = CurIndex.
circuit_choose_start(A,CurIndex,CurDeg,BestIndex,I,N) =>
    X = A[I],
    Deg = fd_size(X),
    (Deg < CurDeg ->
        CurIndex1 = I,
        CurDeg1 = Deg
    ;
        CurIndex1 = CurIndex,
        CurDeg1 = CurDeg
    ),
    circuit_choose_start(A,CurIndex1,CurDeg1,BestIndex,I+1,N).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Shortest-distance heuristic: For a node, let D0 be the shortest distance to
% it from Start. Then the node cannot be reached at times 1,..., D0, because
% Start is visited at time 1. Likewise, let D1 be the shortest distance from
% the node to Start. Then the node cannot be visited at times (N-D1+2)..N.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
circuit_preprocess(N,P,Start,NeibVect,TNeibVect) =>
    (NeibVect == TNeibVect -> Undirected = 1; Undirected = 0),
    circuit_reason_forward(Start,[Start],1,NeibVect,P,1,N,Done),
    circuit_reason_backward(Start,[Start],1,TNeibVect,P,N+1,N,Undirected,Done),
    if Done == 0 then     % some frontiers are too large to expand, so use the shortest-distance heuristic
        circuit_shortest_distance0(Start,N,NeibVect,SDFromStart),
        circuit_shortest_distance0(Start,N,TNeibVect,SDToStart),
        foreach (I in 1..N, I !== Start)
            foreach (T in 1..SDFromStart[I])
                bp.domain_set_false(P[I], T)
            end,
            foreach (T in (N-SDToStart[I]+2)..N)
                bp.domain_set_false(P[I], T)
            end
        end
    end.
    
circuit_shortest_distance0(Start,N,NeibVect,DistVect) =>
    DistVect = new_array(N),                                % DistVect[I], the shortest distance from Start to node I
    foreach (I in 1..N)
        DistVect[I] = N
    end,      
    DistVect[Start] := 0,
    MinHeap1 = new_min_heap([[0|Start]]),
    circuit_shortest_distance(MinHeap1,N,NeibVect,DistVect).

% Dijkstra's algorithm
circuit_shortest_distance(MinHeap,_N,_NeibVect,_DistVect), heap_is_empty(MinHeap) => true.
circuit_shortest_distance(MinHeap,N,NeibVect,DistVect) =>
    [Dist|Node] = heap_pop(MinHeap),
    Dist1 = Dist+1,
    foreach (Neib in NeibVect[Node])
        if (DistVect[Neib] =< Dist1) then
            true
        else
            heap_push(MinHeap,[Dist1|Neib]),
            DistVect[Neib] := Dist1
        end
    end,
    circuit_shortest_distance(MinHeap,N,NeibVect,DistVect).

%% When expanding forward, the first frontier is [Start] at time 1. After expanding Front, Font1 becomes the new frontier.
%% Assume the agent is in a state in Front at time T. Then, it will be in a state in Front1 at time T+1.
circuit_reason_forward(Start,Front,FrontSize,NeibVect,P,T,N,Done) =>
    (T == N ->
        true
    ; FrontSize =< 512, FrontSize < N-1 ->
        T1 is T+1,
        circuit_expand(Start,NeibVect,Front,Front1),
        circuit_exclude_unreachable(1,N,Front1,P,T1),
        circuit_reason_forward(Start,Front1, len(Front1), NeibVect,P,T1,N,Done)
    ; 
        Done = 0
    ).

%% When expanding backward, the first frontier is [Start] at time N+1
circuit_reason_backward(Start,Front,FrontSize,TNeibVect,P,T,N,Undirected,Done) =>
    (T == 2 ->
        true
    ; FrontSize =< 512, FrontSize < N-1 ->
        T1 is T-1,
        circuit_expand(Start,TNeibVect,Front,Front1),
        circuit_exclude_unreachable(1,N,Front1,P,T1),
        FrontSize1 = len(Front1),        
        if FrontSize1 == 2 && Undirected == 1 then     % the distance to Start is N-T1+1
            Front1 = [X1,X2],                          % visit one at time N-T1+2 and visit the other at time T1
            foreach (TT in N-T1+3..T1-1)
                bp.domain_set_false(P[X1],TT),
                bp.domain_set_false(P[X2],TT)
            end
        end,
        circuit_reason_backward(Start,Front1,FrontSize1,TNeibVect,P,T1,N,Undirected,Done)
    ;
        Done = 0
    ).

% Expand Front to yield the next frontier Front1.
circuit_expand(Start,NeibVect,Front,Front1) =>
    TmpFront = [J : I in Front, J in NeibVect[I], J !== Start],
    Front1 = sort_remove_dups(TmpFront).

% for each E in 1..Max that is not included in Dom, E cannot be mapped to position Pos
circuit_exclude_unreachable(E,Max,_Dom,_P,_Pos), E > Max => true.
circuit_exclude_unreachable(E,Max,[E|Dom],P,Pos) =>
    circuit_exclude_unreachable(E+1,Max,Dom,P,Pos).
circuit_exclude_unreachable(E,Max,[Ed|Dom],P,Pos), E > Ed =>
    circuit_exclude_unreachable(E,Max,Dom,P,Pos).
circuit_exclude_unreachable(E,Max,Dom,P,Pos) =>
    bp.domain_set_false(P[E],Pos),
    circuit_exclude_unreachable(E+1,Max,Dom,P,Pos).

fzn_circuit(List), array(List) =>
	fzn_circuit(to_list(List)).
fzn_circuit(List), list(List) =>
    LB = min([fd_min(V) : V in List]),
    if LB !== 1 then
        transform_circuit_aux(List,List1,LB),
        circuit(List1)
    else
        circuit(List)
    end.

transform_circuit_aux([],NVs,_LB) => NVs=[].
transform_circuit_aux([V|Vs],NVs,LB) =>
    NV #= V-LB+1,
    NVs = [NV|NVsR],
    transform_circuit_aux(Vs,NVsR,LB).
	
	
/************************************************************************* 
subcircuit(L):  L is a list or an array of variables X1,X2,...,Xn.
L forms a subcircuit where Xi = j (j \= i) means that j is the successor of i 
and Xi = i means that i is not in the circuit. No sub-cycles are allowed.
*************************************************************************/
subcircuit(L), list(L) =>
    subcircuit_aux(L.to_array()).
subcircuit(A), array(A) =>
    subcircuit_aux(A).
subcircuit(L) =>
    handle_exception($array_or_list_expected(L), subcircuit).

subcircuit_aux(A), subcircuit_no_loop(A) =>
    circuit_aux(A).
subcircuit_aux({V}) => V = 1.
subcircuit_aux(A) =>
    A.length = N,
    A :: 1..N,
    H = new_array(N,N),                          % H[I,I] = 1 means node I is not in the circuit
    subcircuit_init_adj_matrix(H,A,N,MinK,MaxK),
    H :: 0..1,
    K :: MinK..MaxK,                             % number of vertices in the cycle
    foreach (I in 1..N, J in 1..N)               % channel
        if H[I,J] !== 0 then
            H[I, J] #<=> (A[I] #= J)
        end
    end,
    foreach (I in 1..N)                          % each node has exactly one incoming edge
        sum([H[J,I] : J in 1..N]) #= 1        
    end,
    K #= sum([ #~H[I,I] : I in 1..N]),
    (MinK > 2 ->
        KGt2 = 1,
        KGt1 = 1
    ;
        KGt2 #<=> (K #> 2),
        KGt1 #<=> (K #> 1),
        KGt2 #=> KGt1
    ),
     % ban sub-cycles
    subcircuit_choose_start(H,N,KGt1,MinK,Start),     % Start[I] = 1 iff the cycle starts at vertex I
    P = new_array(N),                            % each in-cycle vertex is mapped to a unique position
    NB is round(log(2,N)+0.5),                   % number of bits needed by log encoding
    Max is 2**NB-1,
    P :: 0..Max,
    foreach (I in 1..N)
        if H[I,I] == 1 then
            P[I] = 0
        else
            bp.sat_encode_dvar(P[I],_),           % get the log encoding
            H[I,I] #<=> P[I] #= 0
        end
    end,
    foreach (I in 1..N)
        Start[I] #=> P[I] #= 1,
        foreach (J in 1..N, I !== J, H[I,J] !== 0)
            H[I,J] #=> #~H[J,J],
            H[I,J] #=> #~H[I,I],
            if I < J then
                #~KGt2 #\/ #~H[I,J] #\/ #~H[J,I]    % no cycle of size 2
            end,
            entail_lfsr_succ(NB, #~Start[J], H[I,J], P[I], P[J])
        end
    end.

subcircuit_no_loop(A) =>
    N = len(A),
    foreach (I in 1..N)
        fd_false(A[I],I)
    end.

subcircuit_init_adj_matrix(H,A,N,MinK,MaxK) =>
    MinK0 = 0,
    MaxK0 = N,
    foreach (I in 1..N)
        (fd_false(A[I], I) -> MinK0 := MinK0+1; true),
        (A[I] == I -> MaxK0 := MaxK0-1; true),
        foreach (J in 1..N)                    % H is a subgraph of A
            if fd_true(A[I],J) then
                true
            else
                H[I,J] = 0
            end
        end
    end,
    MinK = MinK0,
    MaxK = MaxK0.

%
% Start and HasStarted must follow the following pattern:
%      Start = 0 ... 0 1 0 ... 0
% HasStarted = 0 ... 0 1 1 ... 1
%
subcircuit_choose_start(H,N,KGt1,MinK,Start) =>
    Start = new_array(N),                    % Start[I] = 1 iff the cycle starts at vertex I
    Start :: 0..1,                          
    foreach (I in 1..N)
        H[I,I]  #=> #~Start[I]               % I is not in the cycle
    end,
    HasStarted = new_array(N),               % HasStarted[I] iff there exists I1 (I1 =< I) such that Start[I1]
    HasStarted :: 0..1,
    (MinK > 1 ->
        HasStarted[N-MinK+1] #= 1
    ;
        KGt1 #=> HasStarted[N]
    ),
    #~H[1,1] #=> Start[1],
    HasStarted[1] #<=> Start[1],
    foreach (I in 2..N)
        HasStarted[I-1] #=> HasStarted[I],
        Start[I] #=> #~HasStarted[I-1],
        Start[I] #=> HasStarted[I],
        H[I,I] #\/ HasStarted[I-1] #\/ Start[I],                % (#~H[I,I] #/\ #~HasStarted[I-1]) #=> Start[I],
        #~HasStarted[I] #\/ Start[I] #\/ HasStarted[I-1]        % (HasStarted[I] #/\ #~Start[I]) #=> HasStarted[I-1]
    end.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% A is a two-dimensional array. All the non-zero cells of A form a Hamiltonian cycle
% A[R,C] is filled with 0 if it's known to be not in the cycle.
% The total number of non-zero cells is K
%
subcircuit_grid(A) =>
    hcp_grid(A,_,_).

subcircuit_grid(A,K) =>
    hcp_grid(A,_,K).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
hcp_grid(G) =>
    grid_check_matrix(G,hcp_grid,NRows,NCols),
    Vs = [{(R,C), G[R,C]} : R in 1..NRows, C in 1..NCols],
    Es = [{(R,C), (R1,C1), _} : R in 1..NRows, C in 1..NCols, grid_neibs(G,NRows,NCols,R,C,Neibs), (R1,C1) in Neibs],
    hcp(Vs,Es,_K).

hcp_grid(G,Es) =>
    grid_check_matrix(G,hcp_grid,NRows,NCols),
    Vs = [{(R,C), G[R,C]} : R in 1..NRows, C in 1..NCols],    
    (var(Es) ->
        Es = [{(R,C), (R1,C1), _} : R in 1..NRows, C in 1..NCols, grid_neibs(G,NRows,NCols,R,C,Neibs), (R1,C1) in Neibs]
    ;    
        hcp_grid_check_es(NRows,NCols,Es,hcp_grid)
    ),
    hcp(Vs,Es,_K).

hcp_grid(G,Es,K) =>
    grid_check_matrix(G,hcp_grid,NRows,NCols),
    Vs = [{(R,C), G[R,C]} : R in 1..NRows, C in 1..NCols],
    (var(Es) ->
        Es = [{(R,C), (R1,C1), _} : R in 1..NRows, C in 1..NCols, grid_neibs(G,NRows,NCols,R,C,Neibs), (R1,C1) in Neibs]
    ;    
        hcp_grid_check_es(NRows,NCols,Es,hcp_grid)
    ),
    hcp(Vs,Es,K).

hcp(Vs,Es) =>
    hcp(Vs,Es,_).

hcp(Vs,Es,K) =>
    VNumMap = new_map(),
    hcp_scc_check_vs(Vs,1,N,VNumMap,Bs,0,NZeros,0,MinK,hcp),
    AdjMap = new_map(),
    hcp_check_es(N,Es,VNumMap,AdjMap,hcp),
    hcp_aux(Bs,Es,N,K,VNumMap,AdjMap,NZeros,MinK).

hcp_scc_check_vs([],I,N,_VNumMap,Bs,CountZeros0,CountZeros,CountOnes0,CountOnes,_Source) =>
    N = I-1,
    Bs = [],
    CountZeros = CountZeros0,
    CountOnes = CountOnes0.
hcp_scc_check_vs([{V,B}|Vs],I,N,VNumMap,Bs,CountZeros0,CountZeros,CountOnes0,CountOnes,Source) =>
    hcp_scc_check_vertex(V,Source),
    hcp_scc_check_b(B,Source),
    (B == 0 ->
        CountZeros1 = CountZeros0+1,
        CountOnes1 = CountOnes0
    ; B == 1 ->
        CountZeros1 = CountZeros0,
        CountOnes1 = CountOnes0+1
    ;
        CountZeros1 = CountZeros0,
        CountOnes1 = CountOnes0
    ),
    (VNumMap.has_key(V) ->
        handle_exception($duplicated_vertex_name(V), Source)
    ;
        VNumMap.put(V,I)
    ),
    I1 is I+1,
    Bs = [B|Bs1],
    hcp_scc_check_vs(Vs,I1,N,VNumMap,Bs1,CountZeros1,CountZeros,CountOnes1,CountOnes,Source).
hcp_scc_check_vs([VB|_Vs],_I,_N,_VNumMap,_Bs,_CountZeros0,_CountZeros,_CountOnes0,_CountOnes,Source) =>
    handle_exception($invalid_pair(VB), Source).
hcp_scc_check_vs(Vs,_I,_N,_VNumMap,_Bs,_CountZeros0,_CountZeros,_CountOnes0,_CountOnes,Source) =>
    handle_exception($list_expected(Vs), Source).

hcp_scc_check_vertex(V,_Source), ground(V) => true.
hcp_scc_check_vertex(V,Source) =>
    handle_exception($ground_expected(V), Source).

hcp_scc_check_b(B,_Source), var(B) => bp.domain(B,0,1).
hcp_scc_check_b(0,_Source) => true.
hcp_scc_check_b(1,_Source) => true.
hcp_scc_check_b(B,Source) =>
    handle_exception($dvar_expected(B), Source).

hcp_check_es(N,[],_VNumMap,AdjMap,_Source) =>
    foreach (I in 1..N)
        Neibs = AdjMap.get(I,[]),
        Neibs1 = sort_remove_dups(Neibs),
        AdjMap.put(I,Neibs1)
    end.
hcp_check_es(N,[{V1,V2,B}|Es],VNumMap,AdjMap,Source) =>
    hcp_scc_check_vertex(V1,Source),
    hcp_scc_check_vertex(V2,Source),
    I1 = VNumMap.get(V1,0),
    (I1 == 0 -> handle_exception($unknown_vertex_name(V1), Source); true),
    I2 = VNumMap.get(V2,0),
    (I2 == 0 -> handle_exception($unknown_vertex_name(V2), Source); true),
    Neibs1 = AdjMap.get(I1,[]),
    AdjMap.put(I1,[I2|Neibs1]),
    hcp_scc_check_b(B,Source),
    hcp_check_es(N,Es,VNumMap,AdjMap,Source).
hcp_check_es(_N,[E|_Es],_VNumMap,_AdjMap,Source) =>
    handle_exception($invalid_triplet(E), Source).
hcp_check_es(_N,Es,_VNumMap,_AdjMap,Source) =>
    handle_exception($list_expected(Es), Source).

hcp_grid_check_es(_NRows,_NCols,[],_Source) => true.
hcp_grid_check_es(NRows,NCols, [{(R1,C1), (R2,C2), _B}|Es],Source) =>
    (R1 >= 1, R1 <= NRows, C1 >= 1, C1 <= NCols ->
        true
    ;
        handle_exception($invalid_grid_coordinate(R1,C1), Source)
    ),
    (R2 >= 1, R2 <= NRows, C2 >= 1, C2 <= NCols ->
        true
    ;
        handle_exception($invalid_grid_coordinate(R2,C2), Source)
    ),
    hcp_grid_check_es(NRows,NCols,Es,Source).
hcp_grid_check_es(_NRows,_NCols,[E|_Es],Source) =>
    handle_exception($invalid_triplet(E), Source).
hcp_grid_check_es(_NRows,_NCols,Es,Source) =>
    handle_exception($list_expected(Es), Source). 

hcp_aux(_Bs,Es,N,K,VNumMap,AdjMap,_NZeros,MinK), MinK == N =>    % all vertices are in, convert this to circuit
    K = N,
    A = new_array(N),
    A :: 1..N,
    foreach (I in 1..N)
        Neibs = AdjMap.get(I),
        A[I] :: Neibs
    end,
    foreach ({V1,V2,B} in Es)
        I1 = VNumMap.get(V1),
        I2 = VNumMap.get(V2),
        A[I1] #= I2 #<=> B
    end,
    circuit(A).
hcp_aux(Bs,Es,N,K,VNumMap,AdjMap,NZeros,MinK) =>
    A = to_array(Bs),
    MaxK = max(N-NZeros,1),
    K :: MinK..MaxK,
    sum(Bs) #= K,
    (MinK > 2 ->
        KGt2 = 1,
        KGt1 = 1
    ;
        KGt2 #<=> (K #> 2),
        KGt1 #<=> (K #> 1),
        KGt2 #=> KGt1
    ),
    H = new_array(N,N),                              % H[I,J] = 1 iff edge (I,J) is in the cycle
    foreach ({V1,V2,B} in Es)
        I1 = VNumMap.get(V1),
        I2 = VNumMap.get(V2),
        H[I1,I2] = B,
        (I1 != I2 ->
            B #=> A[I1],
            B #=> A[I2]
        ;
            true
        )
    end,
    foreach (I in 1..N, J in 1..N)
        Cell = H[I,J], 
        if var(Cell) && not dvar(Cell) then
            Cell = 0
        end
    end,
    foreach (I in 1..N)                              % each vertex has exactly one incoming and one outgoing edge
        TmpB #\/ #~A[I] #\/ #~KGt1,                 
        TmpB #=> sum([H[I,J] : J in 1..N, J !== I]) #= 1,
        TmpB #=> sum([H[J,I] : J in 1..N, J !== I]) #= 1        
    end,
     % ban sub-cycles
    hcp_scc_choose_start(A,N,KGt1,MinK,Start),       % Start[I] = 1 iff the cycle starts at vertex I
    DistA = new_array(N),                             % each in-cycle vertex has a unique distance from the start
    DistA :: 0..MaxK-1,
    foreach (I in 1..N)
        Start[I] #=> DistA[I] #= 0,
        Neibs = AdjMap.get(I,[]),
        foreach (J in Neibs, H[I,J] !== 0)
            if I < J then
                #~KGt2 #\/ #~H[I,J] #\/ #~H[J,I]    % no cycle of size 2
            end,
            #~Start[J] #/\ H[I,J] #=>  DistA[J] #= DistA[I]+1
        end
    end.

%
% Start and HasStarted must follow the following pattern:
%      Start = 0 ... 0 1 0 ... 0
% HasStarted = 0 ... 0 1 1 ... 1
%
hcp_scc_choose_start(A,N,_KGt1,_MinK,Start),
    between(1,N,StartI),
    A[StartI] == 1                          % choose the first index that is known to be in
=>
    Start = new_array(N),
    Start[StartI] = 1,
    foreach (I in 1..N, I !== StartI)
        Start[I] = 0
    end.
hcp_scc_choose_start(A,N,KGt1,MinK,Start) =>
    Start = new_array(N),                    % Start[I] = 1 iff the cycle starts at vertex I
    Start :: 0..1,                          
    foreach (I in 1..N)
        #~A[I]  #=> #~Start[I]               % I is not in the cycle
    end,
    HasStarted = new_array(N),               % HasStarted[I] iff there exists I1 (I1 =< I) such that Start[I1]
    HasStarted :: 0..1,
    (MinK > 1 ->
        HasStarted[N-MinK+1] #= 1
    ;
        KGt1 #=> HasStarted[N]
    ),
    A[1] #=> Start[1],
    HasStarted[1] #<=> Start[1],
    foreach (I in 2..N)
        HasStarted[I-1] #=> HasStarted[I],
        Start[I] #=> #~HasStarted[I-1],
        Start[I] #=> HasStarted[I],
        #~A[I] #\/ HasStarted[I-1] #\/ Start[I],                % (A[I] #/\ #~HasStarted[I-1]) #=> Start[I],
        #~HasStarted[I] #\/ Start[I] #\/ HasStarted[I-1]        % (HasStarted[I] #/\ #~Start[I]) #=> HasStarted[I-1]
    end.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
scc_grid(G) =>
    scc_grid(G,_K).

scc_grid(G,K) =>
    grid_check_matrix(G,scc_grid,NRows,NCols),
    Vs = [{(R,C), G[R,C]} : R in 1..NRows, C in 1..NCols],
    Es = [{Pos,Pos1,_} : R in 1..NRows, C in 1..NCols,
                         Pos = (R,C),
                         grid_neibs(G,NRows,NCols,R,C,Neibs),
                         Pos1 in Neibs,
                         Pos @=< Pos1],
    scc(Vs,Es,K).

scc(Vs,Es) =>
    scc(Vs,Es,_).

scc(Vs,Es,K) =>
    VNumMap = new_map(),
    hcp_scc_check_vs(Vs,1,N,VNumMap,Bs,0,NZeros,0,MinK,scc),
    AdjMap = new_map(),
    EMap = new_map(),
    A = to_array(Bs),
    sum(Bs) #= K,
    scc_check_es(A,N,Es,VNumMap,AdjMap,EMap,scc),
    scc_aux(A,N,K,AdjMap,NZeros,MinK).

scc_check_es(_A,_N,[],_VNumMap,_AdjMap,EMap,_Source) => true.
scc_check_es(A,N,[{V1,V2,B}|Es],VNumMap,AdjMap,EMap,Source) =>
    hcp_scc_check_vertex(V1,Source),
    hcp_scc_check_vertex(V2,Source),
    hcp_scc_check_b(B,Source),
    if EMap.has_key((V1,V2)) then
        EMap.get((V1,V2)) = B
    else
        EMap.put((V1,V2),B),                                % undirected
        EMap.put((V2,V1),B),
        I1 = VNumMap.get(V1,0),
        (I1 == 0 -> handle_exception($unknown_vertex_name(V1), Source); true),
        I2 = VNumMap.get(V2,0),
        (I2 == 0 -> handle_exception($unknown_vertex_name(V2), Source); true),
        Neibs1 = AdjMap.get(I1,[]),
        bp.domain(P21,0,1),    % I2 is I1's parent
        AdjMap.put(I1, [{I2,B,P21}|Neibs1]),
        Neibs2 = AdjMap.get(I2,[]),
        bp.domain(P12,0,1),    % I1 is I2's parent
        AdjMap.put(I2, [{I1,B,P12}|Neibs2]),
        #~P12 #\/ #~P21,                                   % parent is a one-way relation
        #~P12 #\/ B,
        #~P21 #\/ B,                                       % if I1 and I2 are parent-child, then the edge must be in
        #~B #\/ A[I1], #~B #\/ A[I2]                       % if the edge (V1,V2) is in, then both V1 and V2 are in
    end,
    scc_check_es(A,N,Es,VNumMap,AdjMap,EMap,Source).
scc_check_es(_A,_N,[E|_Es],_VNumMap,_AdjMap,EMap,Source) =>
    handle_exception($invalid_triplet(E), Source).
scc_check_es(_A,_N,Es,_VNumMap,_AdjMap,EMap,Source) =>
    handle_exception($list_expected(Es), Source).

scc_aux(A,N,K,AdjMap,NZeros,MinK) =>
    MaxK = max(N-NZeros,1),
    K :: MinK..MaxK,
    (MinK > 1 ->
        KGt1 = 1
    ;
        KGt1 #<=> (K #> 1)
    ),
    hcp_scc_choose_start(A,N,KGt1,MinK,Start),     % Start[I] = 1 iff vertex I is the root of the tree
    DistA = new_array(N),
    MaxDist = MaxK-1,
    DistA :: 0..MaxDist,
    foreach (I in 1..N)
        if A[I] == 0 then
            DistA[I] = 0
        else
            Neibs = AdjMap.get(I,[]),
            if Start[I] == 1 then                  % I has been set to be the root
                DistA[I] = 0,
                foreach ({J,B,P} in Neibs)
                    B #=> DistA[J] #= 1,
                    B #=> A[J],
                    P = 0
                end
            else
                Start[I] #=> DistA[I] #= 0,
                Start[I] #=> sum([P : {_,_,P} in Neibs]) #= 0,
                #~Start[I] #/\ A[I] #=> sum([P : {_,_,P} in Neibs]) #= 1,
                foreach ({J,_B,P} in Neibs)
                    P #=> DistA[I] #= DistA[J]+1
                end
            end
        end
    end.

grid_check_matrix(A,Source,NRows,NCols) =>
    (array(A) -> true; handle_exception($array_expected(A), Source)),
    NRows = len(A),
    foreach (R in 1..NRows)
        (array(A[R]) -> true; handle_exception($array_expected(A[R]), Source))
    end,
    NCols = len(A[1]).

grid_neibs(A,NRows,NCols,R,C,Neibs) =>
        Neibs = [(R1, C1) : (R1, C1) in [(R-1,C), (R+1,C), (R,C-1), (R,C+1)],
                            R1 >= 1, R1 =< NRows, C1 >= 1, C1 =< NCols, A[R1,C1] !== 0].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    
scc_d_grid(G) =>
    scc_d_grid(G,_K).

scc_d_grid(G,K) =>
    grid_check_matrix(G,scc_grid,NRows,NCols),
    Vs = [{(R,C), G[R,C]} : R in 1..NRows, C in 1..NCols],
    Es = [{Pos,Pos1,_} : R in 1..NRows, C in 1..NCols,
                         Pos = (R,C),
                         grid_neibs(G,NRows,NCols,R,C,Neibs),
                         Pos1 in Neibs],
    scc_d(Vs,Es,K).

scc_d(Vs,Es) =>
    scc_d(Vs,Es,_).

scc_d(Vs,Es,K) =>
    VMap = new_map(),
    DegMap = new_map(),
    foreach({V,B} in Vs)
        B :: 0..1,
        VMap.put(V, B),
        DegMap.put(V, 0)
    end,
    K #= sum([B : {_,B} in Vs]),
    %
    foreach ({V1,V2,B} in Es)
        B :: 0..1,
        B1 = VMap.get(V1),
        B2 = VMap.get(V2),
        B #=> B1,
        B #=> B2
    end,
    %    
    VEMap = new_map(),
    foreach({V1,V2,B} in Es)
        Key = (V1,V2),
        VEMap.put(Key,[B]),
        DegMap.put(V1, DegMap.get(V1)+1),
        DegMap.put(V2, DegMap.get(V2)+1)
    end,
    RVs = [V : {V,_} in Vs],
    scc_d_vertex_elimination(VMap, DegMap, VEMap, 0, RVs).      % GEmpty = 0, initial graph is not empty

scc_d_vertex_elimination(VMap, DegMap,  VEMap, GEmpty, [])  => GEmpty = 1.            
scc_d_vertex_elimination(VMap, DegMap,  VEMap, GEmpty, [FV|RVs]) =>
    choose_vertex_to_cut(DegMap, FV, DegMap.get(FV), RVs, W, RVs1),
    GEmpty1 :: 0..1,
    #~GEmpty #\/ GEmpty1,
    BW = VMap.get(W),
    #~GEmpty #\/ #~BW,                                           % GEmpty -> ~BW
    InNeibs = [(V,Bvw) : V in RVs1, V !== W, Key = (V,W), VEMap.has_key(Key), Bs = VEMap.get(Key), Bvw #= max(Bs)],
    OutNeibs = [(V,Bwv) : V in RVs1, V !== W, Key = (W,V), VEMap.has_key(Key), Bs = VEMap.get(Key), Bwv #= max(Bs)],    
    foreach((V,_) in InNeibs)
        DegMap.put(V, DegMap.get(V)-1)
    end,
    foreach((V,_) in OutNeibs)
        DegMap.put(V, DegMap.get(V)-1)
    end,
    BInNeibs = [B : (_,B) in InNeibs],
    BOutNeibs = [B : (_,B) in OutNeibs],
    sum([BW|BInNeibs]) #= 1 #=> GEmpty1 #= 1,        % if W has no incoming arcs, G becomes empty after W is eliminated
    sum([BW|BOutNeibs]) #= 1 #=> GEmpty1 #= 1,       % if W has no outgoing arcs, G becomes empty after W is eliminated    
    foreach ((U,Buw) in InNeibs, (V,Bwv) in OutNeibs)
        Key = (U,V),
        if not VEMap.has_key(Key) then
            DegMap.put(U, DegMap.get(U)+1),
            DegMap.put(V, DegMap.get(V)+1)
        end,
        Buw #/\ Bwv #<=> Buv,
        VEMap.put(Key, [Buv|VEMap.get(Key,[])])
    end,
    scc_d_vertex_elimination(VMap, DegMap, VEMap, GEmpty1, RVs1).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
tree(Vs,Es) =>
    tree(Vs,Es,_).

tree(Vs,Es,K) =>
    scc(Vs,Es,K),    
    EMap = new_map(),
    foreach ({V1,V2,B} in Es)
        if V1 @< V2 then
            EMap.put((V1,V2),B)
        else
            EMap.put((V2,V1),B)
        end
    end,
    L = values(EMap),
    KGe2 #<=> K #>= 2,
    KGe2 #=> K #= sum(L)+1.

register_edge(V1,V2,B,VMap,EMap,AMap) =>
    Key = (V1,V2),
    if EMap.has_key(Key) then
        B = EMap.get(Key)
    else
        EMap.put(Key, B),
        Neibs1 = AMap.get(V1,[]),
        AMap.put(V1,[(V2,B)|Neibs1]),
        if V1 @< V2 then
            B1 = VMap.get(V1),
            B2 = VMap.get(V2),
            B #=> B1,
            B #=> B2
        end
    end.

check_graph_vs([], Source) => true.
check_graph_vs([{V,B}|Vs], Source) =>
    hcp_scc_check_vertex(V,Source),
    hcp_scc_check_b(B,Source),
    check_graph_vs(Vs, Source).
check_graph_vs([E|_], Source) =>
    handle_exception($invalid_pair(E), Source).
check_graph_vs(Vs, Source) =>
    handle_exception($list_expected(Vs), Source).

check_graph_es([], Source) => true.
check_graph_es([{V1,V2,B}|Es], Source) =>
    hcp_scc_check_vertex(V1,Source),
    hcp_scc_check_vertex(V2,Source),    
    hcp_scc_check_b(B,Source),
    check_graph_es(Es, Source).
check_graph_es([E|_], Source) =>
    handle_exception($invalid_triplet(E), Source).
check_graph_es(Es, Source) =>
    handle_exception($list_expected(Es), Source).
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
acyclic(Vs,Es) =>
    check_graph_vs(Vs, acyclic),
    check_graph_es(Es, acyclic),
    N = len(Vs),
    TmpT is N div 2,
    (N mod 2 == 0 ->  MaxT is TmpT-1; MaxT is TmpT),
    VMap = new_map(),
    TMap = new_map(),
    foreach ({V,B} in Vs)
        VMap.put(V,B),
        T :: 0..MaxT,
        TMap.put(V,T)
    end,
    AMap = new_map(),
    EMap = new_map(),
    foreach ({V1,V2,B} in Es)
        register_edge(V1,V2,B,VMap,EMap,AMap),
        register_edge(V2,V1,B,VMap,EMap,AMap)
    end,
    ReifMap = new_map(),
    foreach ({V,B} in Vs)
        Time = TMap.get(V),
        Neibs = AMap.get(V,[]),
        K #= sum([B1 : (_,B1) in Neibs]),
        KGe2 #<=> K #>= 2,
        #~KGe2 #=> Time #= 0,
        constrain_neibs(V,Time,TMap,Neibs,ReifMap)
    end.

constrain_neibs(V,Time,TMap,[],ReifMap) => true.
constrain_neibs(V,Time,TMap,[_],ReifMap) => true.
constrain_neibs(V,Time,TMap,[(V1,B1)|L],ReifMap) =>
    Time1 = TMap.get(V1),
    Key = (V,V1),
    BGT1 #<=> Time #> Time1,
    ReifMap.put(Key,BGT1),
    RKey = (V1,V),
    if ReifMap.has_key(RKey) then
        TmpBGT = ReifMap.get(RKey),
        #~BGT1 #\/ #~TmpBGT                            % redundant but could be helpful
    end,
    constrain_neibs_aux(V,Time,BGT1,B1,TMap,L,ReifMap),
    constrain_neibs(V,Time,TMap,L,ReifMap).

constrain_neibs_aux(V,Time,BGT1,B1,TMap,[],ReifMap) => true.
constrain_neibs_aux(V,Time,BGT1,B1,TMap,[(V2,B2)|L],ReifMap) =>
    Time2 = TMap.get(V2),
    Key = (V,V2),
    BGT2 #<=> Time #> Time2,
    ReifMap.put(Key,BGT2),
    RKey = (V2,V),
    if ReifMap.has_key(RKey) then
        TmpBGT = ReifMap.get(RKey),
        #~BGT2 #\/ #~TmpBGT                            % redundant but could be helpful
    end,
    #~B1 #\/ #~B2 #\/ BGT1 #\/ BGT2,
    constrain_neibs_aux(V,Time,BGT1,B1,TMap,L,ReifMap).
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% (Vs,Es) represents a directed acyclic graph
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
acyclic_d(Vs,Es) =>
    check_graph_vs(Vs, acyclic_d),
    check_graph_es(Es, acyclic_d),
    N = len(Vs),
    VMap = new_map(),
    DegMap = new_map(),
    foreach({V,B} in Vs)
        B :: 0..1,
        VMap.put(V, B),
        DegMap.put(V, 0)
    end,
    %
    VEMap = new_map(),
    EMap = new_map(),
    foreach({V1,V2,B} in Es)
        B :: 0..1,    
        Key = (V1,V2),
        if V1 == V2 then
            #~B        
        end,
        if not VEMap.has_key(Key) then
            VEMap.put(Key, B),
            DegMap.put(V1, DegMap.get(V1)+1),
            DegMap.put(V2, DegMap.get(V2)+1)
        end
    end,
    RVs = [V : {V,_} in Vs],
    Tmp = to_int(2.3*size(VEMap)),
    if Tmp > 30*N then
        Threshold = 30*N
    else
        Threshold = Tmp
    end,
    acyclic_vertex_elimination(VMap, DegMap, VEMap, EMap, Threshold, RVs).

acyclic_vertex_elimination(VMap, DegMap,  VEMap, EMap, Threshold, [])  => true.
acyclic_vertex_elimination(VMap, DegMap,  VEMap, EMap, Threshold, [_]) => true.
acyclic_vertex_elimination(VMap, DegMap,  VEMap, EMap, Threshold, Vs@[FirstV|RVs]) =>
    choose_vertex_to_cut(DegMap, FirstV, DegMap.get(FirstV), RVs, W, RVs1),
    if  size(VEMap) > Threshold then
        VBs = [{V,B} : V in Vs, B = VMap.get(V)],
        EBs = [{V1,V2,B} : V1 in Vs, V2 in Vs,  Key = (V1,V2), VEMap.has_key(Key), B = VEMap.get(Key)],
        acyclic_lee_b(VBs,EBs)
    else
        InNeibs = [V: V in RVs1, VEMap.has_key((V,W))],
        OutNeibs = [V: V in RVs1, VEMap.has_key((W,V))],

        foreach(X in InNeibs)
            DegMap.put(X, DegMap.get(X)-1)
        end,

        foreach(Y in OutNeibs)
            DegMap.put(Y, DegMap.get(Y)-1),
            Key1 = (W,Y),            
            Key2 = (Y,W),

            if VEMap.has_key(Key2) then            
                B1 = VEMap.get(Key1),
                B2 = VEMap.get(Key2),
                #~B1 #\/ #~B2
            end
        end,
        
        foreach(X in InNeibs, Y in OutNeibs, X !== Y)
            if not VEMap.has_key((X,Y)) then
                B1 :: 0..1,
                DegMap.put(X, DegMap.get(X)+1),
                DegMap.put(Y, DegMap.get(Y)+1),
                VEMap.put((X,Y), B1)
            end,
            B1 =  VEMap.get((X,Y)),
            B3 =  VEMap.get((X,W)),
            B4 =  VEMap.get((W,Y)),
            (B3 #/\ B4) #=> B1
        end,
        acyclic_vertex_elimination(VMap, DegMap, VEMap, EMap, Threshold, RVs1)
    end.

% choose a vertex with the lowest degree    
choose_vertex_to_cut(DegMap, U, Du, Vs, W, RVs), Du =< 1 =>
    W = U, RVs = Vs.
choose_vertex_to_cut(DegMap, U, Du, [], W, RVs) => W = U, RVs = [].
choose_vertex_to_cut(DegMap, U, Du, [V|Vs], W, RVs),
    Dv = DegMap.get(V),
    Dv < Du
=>
    RVs = [U|RVs1],
    choose_vertex_to_cut(DegMap, V, Dv, Vs, W, RVs1).
choose_vertex_to_cut(DegMap, U, Du, [V|Vs], W, RVs) =>
    RVs = [V|RVs1],
    choose_vertex_to_cut(DegMap, U, Du, Vs, W, RVs1).

% use leaf-elimination encoding
acyclic_lee_b(Vs,Es) =>
    acyclic_lee_b(Vs,Es,_).

acyclic_lee_b(Vs,Es,TMap) =>        
    BaseVs = [V : {V,_} in Vs],
    BaseEs = [(V1,V2): {V1,V2,_} in Es],
    base_graph_info(BaseVs,BaseEs,N,RemSet,MaxT),           % A node is put in RemdSet if its removal doesn't affect the cyclicity
    VMap = new_map(),
    TMap = new_map(),
    foreach ({V,B} in Vs)
        VMap.put(V,B),
        T :: 0..MaxT,                                       % vertex V is eliminated at time T
        TMap.put(V,T)
    end,
    AMap = new_map(),
    foreach ({V1,V2,B} in Es)
        acyclic_lee_b_register_edge(V1,V2,B,VMap,AMap)
    end,
    foreach ({V,B} in Vs)
        Time = TMap.get(V),
        if RemSet.has_key(V) then
            Time = 0
        else
            Neibs = AMap.get(V,[]),
            K #= sum([B1 : (_,B1) in Neibs]),
            KGe1 #<=> K #>= 1,
            #~KGe1 #=> Time #= 0,                           % vertex V is eliminated at time 0 if it's a leaf
            #~B #=> Time #= 0,
            acyclic_lee_b_constrain_neibs(V,Time,TMap,Neibs)
        end
    end,
    EMap = new_map(),
    foreach ({V1,V2,B} in Es)
        EMap.put((V1,V2), B)
    end,
    foreach ({V1,V2,B12} in Es)
        if EMap.has_key((V2,V1)) && V1 @< V2 then
            B21 = EMap.get((V2,V1)),
            #~B12 #\/ #~B21                                 % no cycle of 2
        end,
        Neibs = AMap.get(V2,[]),
        foreach ((V3,B23) in Neibs, V3 !== V1)
            if EMap.has_key((V3,V1)) then
                B31 = EMap.get((V3,V1)),
                #~B12 #\/ #~B23 #\/ #~B31
            end
        end
    end.

% AMap: adjacency map
acyclic_lee_b_register_edge(V1,V2,B,VMap,AMap) =>
    Neibs1 = AMap.get(V1,[]),
    AMap.put(V1,[(V2,B)|Neibs1]),
    B1 = VMap.get(V1),
    B2 = VMap.get(V2),
    B #=> B1,
    B #=> B2.

acyclic_lee_b_constrain_neibs(V,Time,TMap,[]) => true.
acyclic_lee_b_constrain_neibs(V,Time,TMap,[(V1,B1)|L]) =>
    Time1 = TMap.get(V1),
    B1 #=> Time #> Time1,
    acyclic_lee_b_constrain_neibs(V,Time,TMap,L).

% extract information about the base graph
%    N : the number of nodes
%   RemSet: all the nodes in the base graph that do not occur in any cycles
%   MaxT: The maximum time (number of iterations) for the leaf-elimination to detect acyclicity
%        
base_graph_info(Vs,Es,N,RemSet,MaxT) =>
    AMap = new_map(),
    foreach ((V1,V2)in Es)
        Neibs = AMap.get(V1,[]),
        AMap.put(V1,[V2|Neibs])
    end,
    TransAMap = new_map(),                 % The transpose graph
    foreach ((V1,V2) in Es)
        Neibs = AMap.get(V2,[]),
        TransAMap.put(V2,[V1|Neibs])
    end,
    RemSet = new_set(),
    eliminate_leaves(Vs,AMap,TransAMap,RemSet),
    N = length(Vs),
    MaxT = N - size(RemSet) - 1.           % all the nodes in RemSet are removed at time 0

eliminate_leaves(Vs,AMap,TransAMap,RemSet) =>
    eliminate_leaves(Vs,Vs1,AMap,TransAMap,RemSet,Flag),
    if Flag == 1 then                     % continue until no leaves exist
        eliminate_leaves(Vs1,AMap,TransAMap,RemSet)
    end.

eliminate_leaves([],Vs1,AMap,TransAMap,RemSet,Flag) => Vs1 = [].
eliminate_leaves([V|Vs],Vs1,AMap,TransAMap,RemSet,Flag),
    acyclic_lee_leaf(V,AMap,TransAMap,RemSet)
=>
    RemSet.put(V),
    Flag = 1,
    eliminate_leaves(Vs,Vs1,AMap,TransAMap,RemSet,Flag).
eliminate_leaves([V|Vs],Vs1,AMap,TransAMap,RemSet,Flag) =>
    Vs1 = [V|Vs1R],
    eliminate_leaves(Vs,Vs1R,AMap,TransAMap,RemSet,Flag).
    
acyclic_lee_leaf(V,AMap,TransAMap,RemSet) ?=>
    Neibs = AMap.get(V,[]),
    foreach (Neib in Neibs)
        RemSet.has_key(Neib)
    end,
    !.
acyclic_lee_leaf(V,AMap,TransAMap,RemSet) =>
    Neibs = TransAMap.get(V,[]),
    foreach (Neib in Neibs)
        RemSet.has_key(Neib)
    end.
        
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% (Vs,Es) represents a path from Src to Dest
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
path(Vs,Es,Src,Dest), list(Dest) =>
    scc(Vs,Es),
    check_graph_vs(Vs, path),
    check_graph_es(Es, path),
    hcp_scc_check_vertex(Src,path),
    foreach (V in Dest)
        hcp_scc_check_vertex(V,path)
    end,
    once member({Src, 1}, Vs),                              % Src is in
    VMap = new_map(),
    foreach ({V,B} in Vs)
        VMap.put(V,B)
    end,
    AMap = new_map(),
    EMap = new_map(),
    foreach ({V1,V2,B} in Es)
        register_edge(V1,V2,B,VMap,EMap,AMap),
        register_edge(V2,V1,B,VMap,EMap,AMap)
    end,
    sum([B : V in Dest, B = VMap.get(V,0)]) #= 1,           % exactly one dest vertex is in
    if member(Src, Dest) then                               % Src is in Dest
        foreach ({V,B} in Vs, V != Src)                     % only Src is in the graph
            B = 0
        end,
        foreach ({_,_,B} in Es)
            B = 0
        end
    else                                                    
        Neibs = AMap.get(Src,[]),
        sum([B1 : (_,B1) in Neibs]) #= 1,
        foreach (V in Dest)
            Bv = VMap.get(V),
            VNeibs = AMap.get(V,[]),
            Bv #=> sum([B1 : (_,B1) in VNeibs]) #= 1        % exactly one of the neibs of V is in if V is in
        end,
        foreach ({V,Bv} in Vs, V != Src, not member(V,Dest))
            VNeibs = AMap.get(V,[]),
            Bv #=> sum([B1 : (_,B1) in VNeibs]) #= 2
        end
    end.
path(Vs,Es,Src,Dest) =>                                     % unique dest
    hcp_scc_check_vertex(Dest,path),
    path(Vs,Es,Src,[Dest]).
        
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the directed graph (Vs,Es) represents a path from Src to Dest
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
path_d(Vs,Es,Src,Dest), list(Dest) =>
    check_graph_vs(Vs, path_d),
    check_graph_es(Es, path_d),
    hcp_scc_check_vertex(Src,path_d),
    foreach (V in Dest)
        hcp_scc_check_vertex(V,path_d)
    end,
    once member({Src, 1}, Vs),                              % Src is in
    N = len(Vs),
    VMap = new_map(),
    DistMap = new_map(),
    foreach ({V,B} in Vs)
        VMap.put(V,B),
        Dist :: 0..N,
        DistMap.put(V, Dist)
    end,
    AMap = new_map(),
    EMap = new_map(),
    foreach ({V1,V2,B} in Es)
        register_d_edge(V1,V2,B,VMap,EMap,AMap)
    end,
    sum([B : V in Dest, B = VMap.get(V,0)]) #= 1,           % exactly one dest vertex is in
    if member(Src, Dest) then                               % Src is in Dest
        foreach ({V,B} in Vs, V != Src)                     % only Src is in the graph
            B = 0
        end,
        foreach ({_,_,B} in Es)
            B = 0
        end
    else                                                    
        Neibs = AMap.get(Src,[]),
        sum([B1 : (_,B1) in Neibs]) #= 1,                   % exactly one outgoing
        DistMap.get(Src) = 0,
        foreach (V in Dest)
            Bv = VMap.get(V),
            BInNeibs = [Buv : {U,_} in Vs, Key = (U,V), EMap.has_key(Key), Buv = EMap.get(Key)],
            Bv #=> sum(BInNeibs) #= 1                       % exactly one incomming
        end,
        foreach ({V,Bv} in Vs, V != Src, not member(V,Dest))
            BInNeibs = [Buv : {U,_} in Vs, Key = (U,V), EMap.has_key(Key), Buv = EMap.get(Key)],
            BOutNeibs = [Bvu : {U,_} in Vs, Key = (V,U), EMap.has_key(Key), Bvu = EMap.get(Key)],    
            Bv #=> sum(BInNeibs) #= 1,
            Bv #=> sum(BOutNeibs) #= 1,
            DistOfV = DistMap.get(V),
            foreach ({U,_} in Vs, Key = (V,U), EMap.has_key(Key), Bvu = EMap.get(Key))
                DistOfU = DistMap.get(U),
                Bvu #=> DistOfU #= DistOfV+1
            end
        end
    end.
path_d(Vs,Es,Src,Dest) =>                                   % unique dest
    hcp_scc_check_vertex(Dest,path_d),
    path_d(Vs,Es,Src,[Dest]).

register_d_edge(V1,V2,B,VMap,EMap,AMap) =>
    Key = (V1,V2),
    if EMap.has_key(Key) then
        B = EMap.get(Key)
    else
        EMap.put(Key, B),
        Neibs1 = AMap.get(V1,[]),
        AMap.put(V1,[(V2,B)|Neibs1]),
        B1 = VMap.get(V1),
        B2 = VMap.get(V2),
        B #=> B1,
        B #=> B2
    end.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% if B, then Y is the successor of X
entail_lfsr_succ(NB,B1,B2,X,Y) =>
    (var(X) ->
        get_attr(X,'$bool_vars') = $log(_,VectX)
    ;
        VectX = new_array(NB),
        dec_to_bin(X,1,NB,VectX)
    ),
    (var(Y) ->
        get_attr(Y,'$bool_vars') = $log(_,VectY)
    ;
        VectY = new_array(NB),
        dec_to_bin(Y,1,NB,VectY)
    ),
    entail_lfsr_succ_aux(B1,B2,VectX,VectY).

dec_to_bin(_Val,I,NB,_Vect), I > NB => true.
dec_to_bin(Val,I,NB,Vect) =>
   Vect[I] = Val mod 2,
   dec_to_bin(Val div 2, I+1, NB, Vect).

bin_to_dec(_Vect,I,Res0,Res), I == 0 => Res = Res0.
bin_to_dec(Vect,I,Res0,Res) =>
    bin_to_dec(Vect, I-1, 2*Res0+Vect[I], Res).

% B -> Y = succ(X)
entail_lfsr_succ_aux(B1,B2,{X1,X2},Y) =>    % taps = {1,2}
    Y = {Y1,Y2},
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X1,X2).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3},Y) =>    % taps = {2,3}
    Y = {Y1,Y2,Y3},
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X2,X3).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3,X4},Y) =>    % taps = {3,4}
    Y = {Y1,Y2,Y3,Y4},
    entail_equiv(B1,B2,Y4,X3),
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X3,X4).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3,X4,X5},Y) =>    % taps = {3,5}
    Y = {Y1,Y2,Y3,Y4,Y5},
    entail_equiv(B1,B2,Y5,X4),
    entail_equiv(B1,B2,Y4,X3),
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X3,X5).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3,X4,X5,X6},Y) =>    % taps = {5,6}
    Y = {Y1,Y2,Y3,Y4,Y5,Y6},
    entail_equiv(B1,B2,Y6,X5),
    entail_equiv(B1,B2,Y5,X4),
    entail_equiv(B1,B2,Y4,X3),
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X5,X6).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3,X4,X5,X6,X7},Y) =>    % taps = {6,7}
    Y = {Y1,Y2,Y3,Y4,Y5,Y6,Y7},
    entail_equiv(B1,B2,Y7,X6),
    entail_equiv(B1,B2,Y6,X5),
    entail_equiv(B1,B2,Y5,X4),
    entail_equiv(B1,B2,Y4,X3),
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X6,X7).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3,X4,X5,X6,X7,X8},Y) =>    % taps = {4,5,6,8}
    Y = {Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8},
    entail_equiv(B1,B2,Y8,X7),
    entail_equiv(B1,B2,Y7,X6),
    entail_equiv(B1,B2,Y6,X5),
    entail_equiv(B1,B2,Y5,X4),
    entail_equiv(B1,B2,Y4,X3),
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X4,X5,X6,X8).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3,X4,X5,X6,X7,X8,X9},Y) =>    % taps = {5,9}
    Y = {Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8,Y9},
    entail_equiv(B1,B2,Y9,X8),
    entail_equiv(B1,B2,Y8,X7),
    entail_equiv(B1,B2,Y7,X6),
    entail_equiv(B1,B2,Y6,X5),
    entail_equiv(B1,B2,Y5,X4),
    entail_equiv(B1,B2,Y4,X3),
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X5,X9).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3,X4,X5,X6,X7,X8,X9,X10},Y) =>    % taps = {7,10}
    Y = {Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8,Y9,Y10},
    entail_equiv(B1,B2,Y10,X9),
    entail_equiv(B1,B2,Y9,X8),
    entail_equiv(B1,B2,Y8,X7),
    entail_equiv(B1,B2,Y7,X6),
    entail_equiv(B1,B2,Y6,X5),
    entail_equiv(B1,B2,Y5,X4),
    entail_equiv(B1,B2,Y4,X3),
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X7,X10).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11},Y) =>    % taps = {9,11}
    Y = {Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8,Y9,Y10,Y11},
    entail_equiv(B1,B2,Y11,X10),
    entail_equiv(B1,B2,Y10,X9),
    entail_equiv(B1,B2,Y9,X8),
    entail_equiv(B1,B2,Y8,X7),
    entail_equiv(B1,B2,Y7,X6),
    entail_equiv(B1,B2,Y6,X5),
    entail_equiv(B1,B2,Y5,X4),
    entail_equiv(B1,B2,Y4,X3),
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X9,X11).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12},Y) =>    % taps = {4,10,11,12}
    Y = {Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8,Y9,Y10,Y11,Y12},
    entail_equiv(B1,B2,Y12,X11),
    entail_equiv(B1,B2,Y11,X10),
    entail_equiv(B1,B2,Y10,X9),
    entail_equiv(B1,B2,Y9,X8),
    entail_equiv(B1,B2,Y8,X7),
    entail_equiv(B1,B2,Y7,X6),
    entail_equiv(B1,B2,Y6,X5),
    entail_equiv(B1,B2,Y5,X4),
    entail_equiv(B1,B2,Y4,X3),
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X4,X10,X11,X12).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13},Y) =>    % taps = {8,11,12,13}
    Y = {Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8,Y9,Y10,Y11,Y12,Y13},
    entail_equiv(B1,B2,Y13,X12),
    entail_equiv(B1,B2,Y12,X11),
    entail_equiv(B1,B2,Y11,X10),
    entail_equiv(B1,B2,Y10,X9),
    entail_equiv(B1,B2,Y9,X8),
    entail_equiv(B1,B2,Y8,X7),
    entail_equiv(B1,B2,Y7,X6),
    entail_equiv(B1,B2,Y6,X5),
    entail_equiv(B1,B2,Y5,X4),
    entail_equiv(B1,B2,Y4,X3),
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X8,X11,X12,X13).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14},Y) =>    % taps = {2,12,13,14}
    Y = {Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8,Y9,Y10,Y11,Y12,Y13,Y14},
    entail_equiv(B1,B2,Y14,X13),
    entail_equiv(B1,B2,Y13,X12),
    entail_equiv(B1,B2,Y12,X11),
    entail_equiv(B1,B2,Y11,X10),
    entail_equiv(B1,B2,Y10,X9),
    entail_equiv(B1,B2,Y9,X8),
    entail_equiv(B1,B2,Y8,X7),
    entail_equiv(B1,B2,Y7,X6),
    entail_equiv(B1,B2,Y6,X5),
    entail_equiv(B1,B2,Y5,X4),
    entail_equiv(B1,B2,Y4,X3),
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X2,X12,X13,X14).

% B => X = Y
% i.e., (~B \/ ~X \/ Y) /\ (~B \/ X \/ ~Y)
entail_equiv(B1,B2,X,Y) =>
    #~B1 #\/ #~B2 #\/ #~X #\/ Y,
    #~B1 #\/ #~B2 #\/ X #\/ #~Y.

% B => Y = X1 ^ X2
entail_xor(B1,B2,Y,X1,X2) =>
    #~B1 #\/ #~B2 #\/ #~Y #\/ X1 #\/ X2,       % 1100 1
    #~B1 #\/ #~B2 #\/ Y #\/ #~X1 #\/ X2,       % 1010 1
    #~B1 #\/ #~B2 #\/ Y #\/ X1 #\/ #~X2,       % 1001 1
    #~B1 #\/ #~B2 #\/ #~Y #\/ #~X1 #\/ #~X2.   % 1111 1

% B => Y = X1 ^ X2 ^ X3 ^ X4
entail_xor(B1,B2,Y,X1,X2,X3,X4) =>
    #~B1 #\/ #~B2 #\/ #~Y #\/ X1 #\/ X2 #\/ X3 #\/ X4,
    #~B1 #\/ #~B2 #\/ Y #\/ #~X1 #\/ X2 #\/ X3 #\/ X4,
    #~B1 #\/ #~B2 #\/ Y #\/ X1 #\/ #~X2 #\/ X3 #\/ X4,
    #~B1 #\/ #~B2 #\/ #~Y #\/ #~X1 #\/ #~X2 #\/ X3 #\/ X4,
    #~B1 #\/ #~B2 #\/ Y #\/ X1 #\/ X2 #\/ #~X3 #\/ X4,
    #~B1 #\/ #~B2 #\/ #~Y #\/ #~X1 #\/ X2 #\/ #~X3 #\/ X4,
    #~B1 #\/ #~B2 #\/ #~Y #\/ X1 #\/ #~X2 #\/ #~X3 #\/ X4,
    #~B1 #\/ #~B2 #\/ Y #\/ #~X1 #\/ #~X2 #\/ #~X3 #\/ X4,
    #~B1 #\/ #~B2 #\/ Y #\/ X1 #\/ X2 #\/ X3 #\/ #~X4,
    #~B1 #\/ #~B2 #\/ #~Y #\/ #~X1 #\/ X2 #\/ X3 #\/ #~X4,
    #~B1 #\/ #~B2 #\/ #~Y #\/ X1 #\/ #~X2 #\/ X3 #\/ #~X4,
    #~B1 #\/ #~B2 #\/ Y #\/ #~X1 #\/ #~X2 #\/ X3 #\/ #~X4,
    #~B1 #\/ #~B2 #\/ #~Y #\/ X1 #\/ X2 #\/ #~X3 #\/ #~X4,
    #~B1 #\/ #~B2 #\/ Y #\/ #~X1 #\/ X2 #\/ #~X3 #\/ #~X4,
    #~B1 #\/ #~B2 #\/ Y #\/ X1 #\/ #~X2 #\/ #~X3 #\/ #~X4,
    #~B1 #\/ #~B2 #\/ #~Y #\/ #~X1 #\/ #~X2 #\/ #~X3 #\/ #~X4.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
global_cardinality(List,Keys,Cards) =>
    N = len(List),
    foreach (Card in Cards)
        Card :: 0..N
    end,
    LB = sum([fd_min(Card) : Card in Cards]),
    SumCards :: LB..N,
    SumCards #= sum(Cards),
    (LB == N, ground(Keys) ->
        List :: Keys
    ;
        true
    ),
    foreach ({Key,Card} in zip(Keys,Cards))
      count(Key,List, #= ,Card)
    end.

global_cardinality_closed(List,Keys,Cards) =>
    global_cardinality(List,Keys,Cards),
    foreach (X in List)
        fd_member(X,Keys)
    end.

fd_member(X,L), ground(L) =>
    X :: L.
fd_member(X,L) =>
    sum([X #= E : E in L]) #>= 1.
    
global_cardinality(List,Keys,Lows,Ups) =>
    M = len(Keys),
    Cards = new_list(M),
    global_cardinality(List,Keys,Cards),
    foreach ({Low,Up,Card} in zip(Lows,Ups,Cards))
        Low #=< Card,
        Card #=< Up
    end.
        
global_cardinality_closed(List,Keys,Lows,Ups) =>
    global_cardinality(List,Keys,Lows,Ups),
    foreach (X in List)
        fd_member(X,Keys)
    end.

global_cardinality_low_up(X,Cover,LBound,UBound) =>
    N = len(Cover),
    T = new_array(N),
    foreach(I in 1..N)
        T[I] :: LBound[I]..UBound[I],
        count(Cover[I], X, #=, T[I])
    end.

global_cardinality_low_up_closed(X,Cover,LBound,UBound) =>
    N = len(X),
    CoverList = to_list(Cover),
    X :: CoverList,
    global_cardinality_low_up(X, Cover, LBound, UBound),
    % Implied condition
    N #>= sum(LBound),
    N #=< sum(UBound).
    
global_cardinality(List,Pairs) =>
    (bp.check_pairs(Pairs) -> true; handle_exception($pairs_expected(Pairs), global_cardinality)),
    Cards = [Card : $(_-Card) in Pairs],
    Keys = [Key : $(Key-_) in Pairs],
    global_cardinality(List,Keys,Cards).

% neqs(Neqs) => neqs(Neqs).
neqs(Neqs) =>
    (array(Neqs) -> to_list(Neqs) = List; List = Neqs),    
    check_neqs_args(List,List1),
    foreach ('#\\='(X,Y) in List1)
        X #!= Y
    end.

% serialized(Starts,Durations) => serialized(Starts,Durations).
serialized(Starts,Durations) =>
    Len = Starts.length,
    Os = [1 : _ in 1..Len],
    cumulative(Starts,Durations,Os,1).

/************************************************************************* 
    regular(W,Q,S,M,Q0,Fs)

  W : A sentence (an IntVar array or list)
  Q : number of states
  S : input_max, inputs are from 1 to S
  M : transition matrix:  M[I,J] (I in 1..S, J in 1..Q) is a list of outgoing states for NFA (0 means an error).
  Q0: initial state
  Fs : accepting states
***************************************************************************/
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Model 'regular' as a single-agent path finding problem. Initially the agent
% is in state Q0. For each transition step, the agent consumes a token, and
% moves to the next state. At the end, the agent must be in one of the final states.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/*
regular(L, Q, S, M, Q0, Fs) =>
    regular_constr(L, Q, S, M, Q0, Fs, sat).
*/
regular(W, Q, S, M, Q0, Fs) =>
%    writeln($regular(W, Q, S, M, Q0, Fs)),
    check_regular_args(Q,S,M,Q0,Fs,Matrix,FsLst),  % defined in "common_constr.pi"
    (array(W) -> WArr = W; WArr = to_array(W)),
    N = len(WArr),
    bp.domain(vars(W), 1,S),
    N1 = N+1,
    A = new_array(N1,Q),                           % A[T,State] is true if the agent is in State at time T, A[1,Q0] = 1, T = 1..N+1
    B = new_array(N,S),                            % B[T,Input] is true if the agent observed Input at time T 
    transpose_trans_matrix(Matrix,TMatrix),        % defined in "common_constr.pi"
    preprocess_regular_constr_sat(WArr,Q,S,Matrix,TMatrix,Q0,FsLst,A,B,N),

     % initial and final states
    A[1,Q0] = 1,
    foreach (State in 1..Q, State !== Q0)
        A[1,State] = 0
    end,
    regular_exclude_unreachable(1,Q,FsLst,N1,A),   % set A[N1,State] = 0 if State is not in FsLst
    bp.domain(vars(A), 0,1),
    bp.domain(vars(B), 0,1),

    foreach (T in 2..N)
        sum([A[T,State] : State in 1..Q]) #= 1     % at each time, the agent stays in exactly one state
    end,
    sum([A[N1,State] : State in FsLst]) #= 1,      % at time N, the agent is in one of the final states

     % transition constraints
    foreach (State in 1..Q, Input in 1..S)
        Entry = Matrix[State,Input],
        if list(Entry) then
            foreach (T in 1..N, A[T,State] !== 0, B[T,Input] !== 0)
                sum([ #~A[T,State], #~B[T,Input] | [A[T+1,ToState] : ToState in Entry]]) #>= 1
            end
        elseif Entry !== 0 then
            foreach (T in 1..N, A[T,State] !== 0, B[T,Input] !== 0)        
                #~A[T,State] #\/ #~B[T,Input] #\/ A[T+1,Entry]
            end
        else
            foreach (T in 1..N, A[T,State] !== 0, B[T,Input] !== 0)                
                 #~A[T,State] #\/ #~B[T,Input]    % no transition is possible from State on Input
            end
        end
    end,

     % channel constraints
    foreach (T in 1..N, Input in 1..S)
        (WArr[T] #= Input) #<=> B[T, Input]         % this entails sum([B[T,Input] : Input in 1..S]) #= 1
    end.

%% set A[T,State] to 0 if the agent cannot reach State at time T.
%% set B[T,Input] to 0 if the agent cannot consume Input at time T.
%
preprocess_regular_constr_sat(WArr,Q,S,Matrix,TMatrix,Q0,FsLst,A,B,N) =>
    regular_reason_backward_sat(WArr,Q,S,FsLst, len(FsLst), TMatrix,A,B,N+1,Done),
    regular_reason_forward_sat(WArr,Q,S,[Q0],1,Matrix,A,B,1,N,Done),
    (Done == 0 ->
        regular_sdist_heuristic_sat(Q,S,Matrix,TMatrix,Q0,FsLst,A,N)
    ;
        true
    ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Shortest-distance heuristic: For a state, let D0 be the shortest distance to
% it from Q0. Then the state cannot reached in times 1,..., D0. Likewise, let
% Df be the shortest distance from the state to any final state. Then the state
% cannot be visited in times N-Df+2..N.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
regular_sdist_heuristic_sat(Q,S,Matrix,TMatrix,Q0,FsLst,A,N) =>
    SDFromQ0 = new_array(Q),                                   % SDFromQ0[I], the shortest distance to state I from Q0
    foreach (I in 1..Q)
        SDFromQ0[I] = N
    end,      
    SDFromQ0[Q0] := 0,
    MinHeap1 = new_min_heap([[0|Q0]]),
    fa_shortest_distance(MinHeap1,S,Matrix,SDFromQ0),          % defined in "common_constr.pi"
     %      
    SDFromF = new_array(Q),                                    % SDFromF[I], the shortest distance to I from any state in FsLst
    foreach (I in 1..Q)
        SDFromF[I] = N
    end,      
    foreach (F in FsLst)
        SDFromF[F] := 0
    end,
    MinHeap2 = new_min_heap([[0|FState] : FState in FsLst]),
    fa_shortest_distance(MinHeap2,S,TMatrix,SDFromF),
     %
    foreach (State in 1..Q)
        foreach (T in 2..SDFromQ0[State])
            A[T,State] = 0
        end,
        foreach (T in (N-SDFromF[State]+2)..N)
            A[T,State] = 0
        end
    end.
     %

% Dijkstra's algorithm
fa_shortest_distance(MinHeap,_S,_Matrix,_DistVect), heap_is_empty(MinHeap) => true.
fa_shortest_distance(MinHeap,S,Matrix,DistVect) =>
    [Dist|State] = heap_pop(MinHeap),
    Dist1 = Dist+1,
    foreach (Input in 1..S)
        Entry = Matrix[State,Input],
        if list(Entry) then
            foreach (NextState in Entry)
                if (DistVect[NextState] =< Dist1) then
                    true
                else
                    heap_push(MinHeap,[Dist1|NextState]),
                    DistVect[NextState] := Dist1
                end
            end
       elseif Entry !== 0 then
            if (DistVect[Entry] =< Dist1) then
                true
            else
                heap_push(MinHeap,[Dist1|Entry]),
                DistVect[Entry] := Dist1
            end
        end
    end,
    fa_shortest_distance(MinHeap,S,Matrix,DistVect).

%% When expanding forward, the first frontier is [Q0]. After expanding Front, Font1 becomes the new frontier.
%% Assume the agent is in a state in Front at time T. Then, it will be in a state in Front1 and consume a symbol
%% in Syms at time T+1.
regular_reason_forward_sat(WArr,Q,S,Front,FrontSize,Matrix,A,B,T,N,Done) =>
    (T == N ->
        true
    ; FrontSize == Q ->
        true
    ; FrontSize >= 512 ->
        Done = 0
    ;
        T1 = T+1,
        Wi = WArr[T],
        bp.fd_domain(Wi,Inputs),        
        regular_expand(Inputs,Matrix,Front,Front1,Syms),       % defined in "common_constr.pi"
        regular_exclude_unreachable(1,Q,Front1,T1,A),
        regular_exclude_unreachable(1,S,Syms,T,B),
        regular_reason_forward_sat(WArr,Q,S,Front1, len(Front1), Matrix,A,B,T1,N,Done)
    ).

%% When expanding backward, the first frontier is FsLst at time N
regular_reason_backward_sat(WArr,Q,S,Front,FrontSize,TMatrix,A,B,T,Done) =>
    (T == 2 ->
        true
    ; FrontSize == Q ->
        true
    ; FrontSize >= 512 ->
        Done = 0
    ;
        T1 is T-1,
        Wi = WArr[T1],
        bp.fd_domain(Wi,Inputs),        
        regular_expand(Inputs,TMatrix,Front,Front1,Syms),    
        regular_exclude_unreachable(1,Q,Front1,T1,A),
        regular_exclude_unreachable(1,S,Syms,T1,B),
        regular_reason_backward_sat(WArr,Q,S,Front1, len(Front1), TMatrix,A,B,T1,Done)
    ).

% set Arr[T,Val] = 0 for each Val in 1..Max that is not included in Dom
regular_exclude_unreachable(Val,Max,_Dom,_T,_Arr), Val > Max => true.
regular_exclude_unreachable(Val,Max,[Val|Dom],T,Arr) =>
    regular_exclude_unreachable(Val+1,Max,Dom,T,Arr).
regular_exclude_unreachable(Val,Max,[E|Dom],T,Arr), Val > E =>
    regular_exclude_unreachable(Val,Max,Dom,T,Arr).
regular_exclude_unreachable(Val,Max,Dom,T,Arr) =>
    Arr[T,Val] = 0,
    regular_exclude_unreachable(Val+1,Max,Dom,T,Arr).


%%
%% lex_le(L1,L2): collection L1 is lexicographically less than or equal to L2
%%
lex_le(L1,L2), list(L1), list(L2) =>
    check_args_lex(L1,L2,L11,L22),
    lex_le_aux(L11,L22).
lex_le(L1,L2), array(L1), array(L2) =>
    check_args_lex(to_list(L1), to_list(L2), L11,L22),
    lex_le_aux(L11,L22).
lex_le(L1,L2) =>
    throw($invalid(lex_le(L1,L2))).

%%
%% lex_lt(L1,L2): collection L1 is lexicographically less than L2
%%
lex_lt(L1,L2), list(L1), list(L2) =>
    check_args_lex(L1,L2,L11,L22),
    lex_lt_aux(L11,L22).
lex_lt(L1,L2), array(L1), array(L2) =>
    check_args_lex(to_list(L1), to_list(L2), L11,L22),
    lex_lt_aux(L11,L22).
lex_lt(L1,L2) =>
    throw($invalid(lex_lt(L1,L2))).

check_args_lex(L1,L2,L11,L22) =>
    (bp.dvar_or_int_list(L1) -> true; handle_exception($dvar_list_expected(L1), lex)),
    (bp.dvar_or_int_list(L2) -> true; handle_exception($dvar_list_expected(L2), lex)),
    N1 = length(L1),
    N2 = length(L2),
    (N1 == N2 ->
        L11 = L1, L22 = L2
    ; N1 < N2 ->
        Min = min([fd_min(V) : V in L2]),
        Min1 = Min-1,
        L1Pad = [Min1 : _ in 1..N2-N1],
        L11 = L1 ++ L1Pad, L22 = L2
    ;
        Min = min([fd_min(V) : V in L1]),
        Min1 = Min-1,
        L2Pad = [Min1 : _ in 1..N1-N2],
        L11 = L1, L22 = L2 ++ L2Pad
    ).

% L1 and L2 have the same length
lex_le_aux([],_) => true.
lex_le_aux([X],[Y|_]) => X #=< Y.
lex_le_aux([X1,X2],[Y1,Y2|_]) => (X1 #< Y1) #\/ (X1 #= Y1 #/\ (X2 #=< Y2)).
lex_le_aux(L1,L2) =>
    N = length(L1),
    A1 = to_array(L1),
    A2 = to_array(L2),
    ReifLexLE = new_array(N),
    ReifLexLE[1] = 1,
    ReifLexLE :: 0..1,
    ReifLexLE[N] #<=> (A1[N] #=< A2[N]),
    foreach(I in 2..N-1)
        ReifLexLE[I] #<=> (A1[I] #< A2[I] #\/ ((A1[I] #= A2[I]) #/\ ReifLexLE[I+1]))
    end,
    A1[1] #< A2[1] #\/ ((A1[1] #= A2[1]) #/\ ReifLexLE[2]).
    
% L1 and L2 have the same length 
lex_lt_aux([],_) => true.
lex_lt_aux([X],[Y|_]) => X #< Y.
lex_lt_aux([X1,X2],[Y1,Y2|_]) => (X1 #< Y1) #\/ (X1 #= Y1 #/\ (X2 #< Y2)).
lex_lt_aux(L1,L2) =>
    N = length(L1),
    A1 = to_array(L1),
    A2 = to_array(L2),
    ReifLexLE = new_array(N),
    ReifLexLE :: 0..1,
    ReifLexLE[N] #<=> (A1[N] #< A2[N]),
    foreach(I in 2..N-1)
        ReifLexLE[I] #<=> (A1[I] #< A2[I] #\/ ((A1[I] #= A2[I]) #/\ ReifLexLE[I+1]))
    end,
    A1[1] #< A2[1] #\/ ((A1[1] #= A2[1]) #/\ ReifLexLE[2]).

%%
nvalue(N,L) => bp.'$nvalue'(N,L).

%% Some of the following constraints were proposed and implemented by Hakan Kjellerstrand
matrix_element(M,I,J,MIJ) =>
    check_matrix(M,NRows,NCols),
    matrix_element(M,NRows,NCols,I,J,MIJ,sat).

matrix_element0(M,I,J,MIJ) =>
    check_matrix(M,NRows,NCols),
    matrix_element0(M,NRows,NCols,I,J,MIJ,sat).

%
% Scalar product of the list A and X
%
scalar_product(A, X, Product) => 
    scalar_product(A, X, '#=', Product).

%
% scalar product of List A and X, with one of the relations: 
% 
%   #=, #<, #>, #<=, #>=, #!=
%
scalar_product(A, X, '#=', Product) => 
   check_scalars(A,X),
   sum([A[I]*X[I] : I in 1..A.length]) #= Product.

scalar_product(A, X, '#!=', Product) => 
   check_scalars(A,X),
   sum([A[I]*X[I] : I in 1..A.length]) #!= Product.

scalar_product(A, X, '#>=', Product) => 
   check_scalars(A,X),
   sum([A[I]*X[I] : I in 1..A.length]) #>= Product.

scalar_product(A, X, '#>', Product) => 
   check_scalars(A,X),
   sum([A[I]*X[I] : I in 1..A.length]) #> Product.

scalar_product(A, X, '#<=', Product) => 
   check_scalars(A,X),
    scalar_product(A, X, '#=<', Product).

scalar_product(A, X, '#=<', Product) => 
   check_scalars(A,X),
   sum([A[I]*X[I] : I in 1..A.length]) #=< Product.

scalar_product(A, X, '#<', Product) => 
   check_scalars(A,X),
   sum([A[I]*X[I] : I in 1..A.length]) #< Product.

%
% exactly(?N,?X,?V)
%
% Requires that exactly N variables in X take the value V.
%
exactly(N, X, V) =>
  count(V,X, #= ,N).

%
% at_most(?N,?X,?V)
%
% Requires that atmost N variables in X take the value V.
%
at_most(N,X,V) => 
  count(V,X, #=< ,N).

%
% at_least(?N,?X,?V)
%
% Requires that atleast N variables in X take the value V.
%
at_least(N,X,V) => 
  count(V,X, #>= ,N).

%
% Ensure that List is increasing
%
increasing(FDVars), array(FDVars) =>
   foreach(I in 2..length(FDVars)) FDVars[I-1] #=< FDVars[I] end.
increasing(FDVars), list(FDVars) =>
   increasing_list(FDVars).
increasing(FDVars) =>
   handle_exception($list_or_array_expected(FDVars), increasing).

increasing_list([]) => true.
increasing_list([_]) => true.
increasing_list([X|T@[Y|_]]) => 
    X #=< Y,
    increasing_list(T).

increasing_strict(FDVars), array(FDVars) =>
   foreach(I in 2..length(FDVars)) FDVars[I-1] #< FDVars[I] end.
increasing_strict(FDVars), list(FDVars) =>
   increasing_strict_list(FDVars).
increasing_strict(FDVars) =>
   handle_exception($list_or_array_expected(FDVars), increasing_strict).

increasing_strict_list([]) => true.
increasing_strict_list([_]) => true.
increasing_strict_list([X|T@[Y|_]]) => 
    X #< Y,
    increasing_strict_list(T).

%
% Ensure that FDVars is decreasing
%
decreasing(FDVars), array(FDVars) =>
   foreach(I in 2..length(FDVars)) FDVars[I-1] #>= FDVars[I] end.
decreasing(FDVars), list(FDVars) =>
   decreasing_list(FDVars).
decreasing(FDVars) =>
   handle_exception($list_or_array_expected(FDVars), decreasing).

decreasing_list([]) => true.
decreasing_list([_]) => true.
decreasing_list([X|T@[Y|_]]) => 
    X #>= Y,
    decreasing_list(T).

decreasing_strict(FDVars), array(FDVars) =>
   foreach(I in 2..length(FDVars)) FDVars[I-1] #> FDVars[I] end.
decreasing_strict(FDVars), list(FDVars) =>
   decreasing_strict_list(FDVars).
decreasing_strict(FDVars) =>
   handle_exception($list_or_array_expected(FDVars), decreasing_strict).

decreasing_strict_list([]) => true.
decreasing_strict_list([_]) => true.
decreasing_strict_list([X|T@[Y|_]]) => 
    X #> Y,
    decreasing_strict_list(T).
    
%
% A network flow constraint with cost.
% Arcc = [(Source1,Sink1), ... ]
% balance[j] is the balance of node j.
% weight[i] is the weight of arc i.
% assert: |arc| = |weight| = |flow|, 
%
network_flow_cost(Arcs,Balance,Weight,Flow, Cost) =>
    N_arcs = length(Flow),
    N_nodes = length(Balance),
    Cost #=  sum([Flow[I]*Weight[I] : I in 1..N_arcs]),
    foreach (I in 1..N_nodes)
        Inflow = [Flow[J] : J in 1..N_arcs, Arcs[J,1] == I],
        Outflow = [Flow[J] : J in 1..N_arcs, Arcs[J,2] == I],
        sum(Inflow) - sum(Outflow) #= Balance[I]
    end.

knapsack(WVec, PVec, XVec, W, P) =>	
    N = XVec.len,
    foreach(I in 1..N)
      XVec[I] #>= 0
    end,
    W #>= 0,
    P #>= 0,
    P #= sum([XVec[I]*PVec[I] : I in 1..N]),
    W #= sum([XVec[I]*WVec[I] : I in 1..N]).

%
% For each subsequence vs[i],..., vs[i+seq-1], the sum of the values belongs to the interval [low,up].
%
sliding_sum(Low,Up,Seq,Vs) =>
    N = length(Vs),
    S = new_array(N),
    S[1] = Vs[1],
    foreach (I in 2..N)
        S[I] #= S[I-1] + Vs[I]
    end,
    Low #=< S[Seq],
    S[Seq] #=< Up,
    foreach (I in (Seq+1)..(N-Seq+1))
        T #= S[I] - S[I-Seq],
        Low #=< T,
        T #=< Up
    end.

value_precede(S,T,X), list(X) =>
    value_precede(S,T,to_array(X)).
value_precede(S,T,X), array(X) =>
    XLen = X.length,
    B = new_array(XLen+1),
    B :: 0..1,
    foreach(I in 1..XLen)
        Xis #= (X[I] #= S),
        Xis #=> (B[I+1] #= 1),
        #~ Xis #=> (B[I] #= B[I+1]),
        #~ B[I] #=> (X[I] #!= T)
    end,
    B[1] #= 0.
value_precede(S,T,X) =>
   handle_exception($list_or_array_expected(X), value_precede).

value_precede_chain(C, X), array(C) =>
    foreach(I in 2..C.length)
        value_precede(C[I-1], C[I], X)
    end.
value_precede_chain(C, X), list(C) =>
	A = to_array(C),
	value_precede_chain(A, X).
value_precede_chain(C, X) =>
   handle_exception($list_or_array_expected(X), value_precede_chain).
		
seq_precede_chain(X), list(X) =>
    seq_precede_chain(to_array(X)).
seq_precede_chain(X), array(X) =>    
    N = len(X),
    fd_min_max(X,Low,Up),
    F = 1, % min ( index_set (X ))
    H = new_array(N),
    H :: Low..Up,    
    H[F] #<= 1,
    H[F] #= max(X[F], 0),
    foreach(I in 1..N, I !== F) 
       H[I] #<= H[I-1] + 1,
       H[I] #= max(X[I], H[I-1])
    end.
seq_precede_chain(X) =>
   handle_exception($list_or_array_expected(X), seq_precede_chain).