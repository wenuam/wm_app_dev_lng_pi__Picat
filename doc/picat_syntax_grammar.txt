/* Picat syntax grammar rules 
      [...] means optional
      {...} means 0, 1, or more occurrences
      (a | b) means choice
      "..." means a token
      %... one-line comment

      input tokens:
      	    atom
	    variable
	    integer
	    float
            operator
            separator
            eor is "." followed by a white space

   Last updated: January 3, 2013 
*/
program ->
    [module_declaration]
    {import_declaration}
    program_body

program_body ->
    {include_declaration | predicate_definition | function_definition | actor_definition}

module_declaration -> 
    "module" atom eor

import_declaration ->
    import import_item {"," import_item} eor

import_item ->
    atom ["." atom ["/" integer]]

include_declaration ->
    "include " string {, string} eor

predicate_definition ->
    {predicate_directive} predicate_rule_or_fact {predicate_rule_or_fact}

function_definition ->
    {function_directive} function_rule_or_fact {function_rule_or_fact}

actor_definition ->
    ["private"] action_rule {(action_rule | nonbacktrackable_predicate_rule)}

function_directive ->
    "private"
    "table"

predicate_directive ->
    "private"
    "table" ["(" table_mode {"," table_mode} ")" ]
    "index" "(" index_mode {"," index_mode} ")"

index_mode ->
   "+"
   "-"
   
table_mode ->
   "+"
   "-"
   "min"
   "max"
      
cardinality_limit ->
   "cardinality" "(" integer ")"

predicate_rule_or_fact ->
    predicate_rule
    predicate_fact

function_rule_or_fact ->
    function_rule
    function_fact

predicate_rule ->
    head ["," condition] ("=>" | "?=>") body eor

nonbacktrackable_predicate_rule ->
    head ["," condition] "=>" body eor

predicate_fact ->
    head eor

head ->
    atom ["(" [term {"," term}] ")"]

function_rule ->
    head "=" variable ["," condition] "=>" body eor    

function_fact ->
    head "=" argument eor

action_rule ->
    head ["," condition] "," "{" event_pattern "}"   => body eor

event_pattern ->
    term {',' term}

condition -> goal

body -> goal

goal ->
    disjunctive_goal

argument ->
    negative_goal

disjunctive_goal ->
    conjunctive_goal ";" disjunctive_goal
    conjunctive_goal

conjunctive_goal ->
    negative_goal "," conjunctive_goal 
    negative_goal

negative_goal ->
   "not" negative_goal
   equiv_constr

equiv_constr ->
   equiv_constr "#<=>" impl_constr
   impl_constr

impl_constr ->
   impl_constr "#=>" or_constr
   or_constr

or_constr ->
   or_constr "#\/" xor_constr
   xor_constr

xor_constr ->
   xor_constr "#^" and_constr
   and_constr

and_constr ->
   and_constr "#/\" not_constr
   not_constr

not_constr ->
   "#~" not_constr
   enclosed_goal

enclosed_goal ->
   "if" goal "then" goal {"elseif" goal "then" goal} "else" goal "end"
   "foreach" "(" iterator {"," (iterator | condition)} ")" goal "end"
   "while" "(" goal ")" ["loop"] goal "end"
   "loop" goal "while" "(" goal ")"
   "try" goal {catch_clause} ["finally" goal] "end"
    expression {bin_rel_op expression}

catch_clause ->
    "catch" "(" exception_pattern ")" goal 

exception_pattern -> 
    term

bin_rel_op ->
    "=" 
    "!="
    ":=" 
    "=="
    "!=="
    ">"
    ">="
    "<"
    "=<"
    "<="
    "in"
    "#=" 
    "#!=" 
    "#>" 
    "#>=" 
    "#<" 
    "#=<" 
    "#<=" 

expression -> 
    range_expression.

range_expression ->
   or_expression [".." or_expression [".." or_expression]]
    
or_expression  ->
    xor_expression 
    or_expression "\/" xor_expression

xor_expression ->  
    and_expression 
    xor_expression "^" and_expression   % bit-wise xor

and_expression ->
    shift_expression 
    and_expression  "/\" shift_expression

shift_expression ->
    additive_expression 
    shift_expr ( "<<" | ">>" | ">>>" ) additive_expression 

additive_expression ->
    multiplicative_expression
    additive_expression "+" multiplicative_expression
    additive_expression "++" multiplicative_expression
    additive_expression "-" multiplicative_expression

multiplicative_expression ->
    unary_expression
    multiplicative_expression "*" unary_expression
    multiplicative_expression "/" unary_expression
    multiplicative_expression "//" unary_expression
    multiplicative_expression "/>" unary_expression
    multiplicative_expression "/<" unary_expression
    multiplicative_expression "div" unary_expression
    multiplicative_expression "mod" unary_expression
    multiplicative_expression "rem" unary_expression

    
unary_expression ->
    power_expression
    "+" unary_expression
    "-" unary_expression
    "~" unary_expression    % bit-wise complement

power_expression ->
    primary_expression ["**" unary_expression]

primary_expression ->
    "(" goal ")"
    variable "[" argument ["," argument] "]"    % index notation
    variable "@" term ["@"]                     % as-pattern, can occur in terms only
    variable
    integer
    float
    atom_or_call
    list_expression
    array_expression
    function_call
    lambda_term
    term_constructor
    primary_expression "." atom_or_call    % dot-notation primary can't be lambda

atom_or_call ->
    atom ["(" [argument {"," argument}] ")"]  

list_expression ->
    "[" argument list_expression_suffix "]"

list_expression_suffix ->
    ":" iterator {"," (iterator | condition)}     % list comprehension
    {"," argument} ["|" argument] 

array_expression ->
    "{" argument {"," argument} "}"    

function_call ->
    [primary_expression "."] atom "(" [argument {"," argument}] ")"

lambda_term ->
    "lambda" "(" variable_list, argument ")"

variable_list ->
    "[" [variable {"," variable}] "]"

term_constructor ->
    "$" goal "$"

/* a term has the same form as a goal except that
   (1) a term contains no index notations;
   (2) a term contains no dot notations (O.E);
   (3) a term contains no lambda terms;
   (4) a term contains no loops;
   (5) a term contains no range_expressions;
   (6) a term contains no list comprehensions;
   (7) a term can contain an as-pattern in the form Var@Term@.
*/
